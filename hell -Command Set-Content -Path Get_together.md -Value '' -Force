[1mdiff --git a/COMMIT_CHECKLIST.md b/COMMIT_CHECKLIST.md[m
[1mindex 5d7a30d2..d018f0e4 100644[m
[1m--- a/COMMIT_CHECKLIST.md[m
[1m+++ b/COMMIT_CHECKLIST.md[m
[36m@@ -123,5 +123,6 @@[m [mThe code is production-ready. You just need to set up your local environment to[m
 [m
 [m
 [m
[41m+[m
 [m
 [m
[1mdiff --git a/MASTER_OPERATIONS_GUIDE.md b/MASTER_OPERATIONS_GUIDE.md[m
[1mnew file mode 100644[m
[1mindex 00000000..a90e19c9[m
[1m--- /dev/null[m
[1m+++ b/MASTER_OPERATIONS_GUIDE.md[m
[36m@@ -0,0 +1,387 @@[m
[32m+[m[32m# MASTER OPERATIONS GUIDE[m
[32m+[m
[32m+[m[32m## Complete Guide to Alpha Loop Capital Algorithmic Trading System[m
[32m+[m
[32m+[m[32m---[m
[32m+[m
[32m+[m[32m## TABLE OF CONTENTS[m
[32m+[m
[32m+[m[32m1. [Quick Start](#quick-start)[m
[32m+[m[32m2. [System Architecture](#system-architecture)[m
[32m+[m[32m3. [Data Hydration](#data-hydration)[m
[32m+[m[32m4. [Agent Training](#agent-training)[m
[32m+[m[32m5. [Elite Grading System](#elite-grading-system)[m
[32m+[m[32m6. [Running Scripts](#running-scripts)[m
[32m+[m[32m7. [Monitoring & Dashboards](#monitoring--dashboards)[m
[32m+[m[32m8. [Troubleshooting](#troubleshooting)[m
[32m+[m
[32m+[m[32m---[m
[32m+[m
[32m+[m[32m## QUICK START[m
[32m+[m
[32m+[m[32m### Windows (PowerShell)[m
[32m+[m[32m```powershell[m
[32m+[m[32m# 1. Navigate to project[m
[32m+[m[32mcd C:\Users\tom\Alpha-Loop-LLM\Alpha-Loop-LLM-1[m
[32m+[m
[32m+[m[32m# 2. Activate environment[m
[32m+[m[32m.\venv\Scripts\activate[m
[32m+[m
[32m+[m[32m# 3. Start data hydration (run overnight)[m
[32m+[m[32mpython scripts/hydrate_full_universe.py[m
[32m+[m
[32m+[m[32m# 4. Train agents (in another terminal)[m
[32m+[m[32mpython -m src.training.agent_trainer --all[m
[32m+[m[32m```[m
[32m+[m
[32m+[m[32m### Mac (Terminal)[m
[32m+[m[32m```bash[m
[32m+[m[32m# 1. Navigate to project[m
[32m+[m[32mcd ~/Alpha-Loop-LLM/Alpha-Loop-LLM-1[m
[32m+[m
[32m+[m[32m# 2. Activate environment[m
[32m+[m[32msource venv/bin/activate[m
[32m+[m
[32m+[m[32m# 3. Start data hydration[m
[32m+[m[32mpython scripts/hydrate_full_universe.py[m
[32m+[m
[32m+[m[32m# 4. Train agents[m
[32m+[m[32mpython -m src.training.agent_trainer --all[m
[32m+[m[32m```[m
[32m+[m
[32m+[m[32m---[m
[32m+[m
[32m+[m[32m## SYSTEM ARCHITECTURE[m
[32m+[m
[32m+[m[32m```[m
[32m+[m[32m+------------------+     +------------------+     +------------------+[m
[32m+[m[32m|   DATA SOURCES   |     |   PROCESSING     |     |   EXECUTION      |[m
[32m+[m[32m+------------------+     +------------------+     +------------------+[m
[32m+[m[32m| Polygon.io       |---->| Feature Engine   |---->| Signal Generator |[m
[32m+[m[32m| Alpha Vantage    |     | ML Training      |     | Risk Manager     |[m
[32m+[m[32m| Massive S3       |     | Agent Training   |     | Order Executor   |[m
[32m+[m[32m| FRED             |     | Elite Grading    |     | IBKR Connection  |[m
[32m+[m[32m+------------------+     +------------------+     +------------------+[m
[32m+[m[32m        |                        |                        |[m
[32m+[m[32m        v                        v                        v[m
[32m+[m[32m+------------------+     +------------------+     +------------------+[m
[32m+[m[32m|   STORAGE        |     |   AGENTS         |     |   OUTPUTS        |[m
[32m+[m[32m+------------------+     +------------------+     +------------------+[m
[32m+[m[32m| Azure SQL        |     | 112 Total Agents |     | Trading Signals  |[m
[32m+[m[32m| CSV Backups      |     | HOAGS (Master)   |     | P&L Reports      |[m
[32m+[m[32m| FAISS Vectors    |     | Strategy Agents  |     | Risk Alerts      |[m
[32m+[m[32m+------------------+     +------------------+     +------------------+[m
[32m+[m[32m```[m
[32m+[m
[32m+[m[32m---[m
[32m+[m
[32m+[m[32m## DATA HYDRATION[m
[32m+[m
[32m+[m[32m### What Gets Pulled[m
[32m+[m
[32m+[m[32m| Source | Data Type | Volume | Time |[m
[32m+[m[32m|--------|-----------|--------|------|[m
[32m+[m[32m| Polygon | Stocks, ETFs | 8,000+ symbols | 4-6 hours |[m
[32m+[m[32m| Polygon | Options | 100,000+ contracts | 2-3 hours |[m
[32m+[m[32m| Polygon | Crypto | 500+ pairs | 30 min |[m
[32m+[m[32m| Polygon | Forex | 50+ pairs | 30 min |[m
[32m+[m[32m| Alpha Vantage | Fundamentals | 100+ stocks | 2-3 hours |[m
[32m+[m[32m| Alpha Vantage | Daily prices | 100+ stocks | 2-3 hours |[m
[32m+[m[32m| FRED | Macro data | 50+ series | 15 min |[m
[32m+[m
[32m+[m[32m### Scripts[m
[32m+[m
[32m+[m[32m| Script | Purpose | Command |[m
[32m+[m[32m|--------|---------|---------|[m
[32m+[m[32m| `hydrate_full_universe.py` | ALL Polygon data | `python scripts/hydrate_full_universe.py` |[m
[32m+[m[32m| `hydrate_alpha_vantage.py` | Alpha Vantage data | `python scripts/hydrate_alpha_vantage.py` |[m
[32m+[m[32m| `hydrate_massive.py` | Deep historical data | `python scripts/hydrate_massive.py` |[m
[32m+[m
[32m+[m[32m### Batch Files (Windows - Double-Click)[m
[32m+[m
[32m+[m[32m- `scripts/HYDRATE_QUICK.bat` - Quick test (30 min)[m
[32m+[m[32m- `scripts/HYDRATE_ALPHA_VANTAGE.bat` - Alpha Vantage with menu[m
[32m+[m[32m- `scripts/START_DATA_COLLECTION.bat` - Full hydration[m
[32m+[m
[32m+[m[32m---[m
[32m+[m
[32m+[m[32m## AGENT TRAINING[m
[32m+[m
[32m+[m[32m### Agent Hierarchy[m
[32m+[m
[32m+[m[32m```[m
[32m+[m[32mTIER 1 - MASTERS (Supreme Authority)[m
[32m+[m[32m  HOAGS     - Master strategist, approves all major decisions[m
[32m+[m[32m  GHOST     - Autonomous operations, independent judgment[m
[32m+[m
[32m+[m[32mTIER 2 - SENIOR (Core Operations)[m
[32m+[m[32m  SCOUT     - Market reconnaissance, opportunity identification[m
[32m+[m[32m  HUNTER    - Trade execution, alpha capture[m
[32m+[m[32m  ORCHESTRATOR - Multi-agent coordination[m
[32m+[m[32m  KILLJOY   - Risk management, kill switches[m
[32m+[m[32m  BOOKMAKER - Options pricing, volatility[m
[32m+[m[32m  STRINGS   - Position management, allocation[m
[32m+[m[32m  SKILLS    - Capability development[m
[32m+[m[32m  AUTHOR    - Documentation, learning[m
[32m+[m
[32m+[m[32mTIER 3 - STRATEGY (Trading Strategies)[m
[32m+[m[32m  MOMENTUM, MEAN_REVERSION, VALUE, GROWTH, VOLATILITY[m
[32m+[m[32m  SENTIMENT, LIQUIDITY, MACRO, OPTIONS, CRYPTO, PAIRS, ARBITRAGE[m
[32m+[m
[32m+[m[32mTIER 4 - SECTOR (Industry Focus)[m
[32m+[m[32m  TECH, HEALTHCARE, ENERGY, FINANCIALS, etc.[m
[32m+[m[32m```[m
[32m+[m
[32m+[m[32m### Training Commands[m
[32m+[m
[32m+[m[32m```powershell[m
[32m+[m[32m# Train ALL agents[m
[32m+[m[32mpython -m src.training.agent_trainer --all[m
[32m+[m
[32m+[m[32m# Train specific agent[m
[32m+[m[32mpython -m src.training.agent_trainer --agent HOAGS[m
[32m+[m
[32m+[m[32m# Train specific tier[m
[32m+[m[32mpython -m src.training.agent_trainer --tier SENIOR[m
[32m+[m[32mpython -m src.training.agent_trainer --tier STRATEGY[m
[32m+[m[32m```[m
[32m+[m
[32m+[m[32m### Training Output[m
[32m+[m
[32m+[m[32mResults saved to: `data/training_results/`[m
[32m+[m
[32m+[m[32m```json[m
[32m+[m[32m{[m
[32m+[m[32m  "agent_name": "MOMENTUM",[m
[32m+[m[32m  "grade": "ELITE",[m
[32m+[m[32m  "score": 87.5,[m
[32m+[m[32m  "passed_elite": true,[m
[32m+[m[32m  "sharpe_ratio": 2.45,[m
[32m+[m[32m  "win_rate": 0.58,[m
[32m+[m[32m  "unique_edges": ["Fast adaptation: 4 days", "Survives tail events"][m
[32m+[m[32m}[m
[32m+[m[32m```[m
[32m+[m
[32m+[m[32m---[m
[32m+[m
[32m+[m[32m## ELITE GRADING SYSTEM[m
[32m+[m
[32m+[m[32m### What Makes It Different[m
[32m+[m
[32m+[m[32mStandard quant funds measure basic metrics. We measure UNIQUE features:[m
[32m+[m
[32m+[m[32m| Metric | Standard Fund | Our System |[m
[32m+[m[32m|--------|---------------|------------|[m
[32m+[m[32m| Sharpe Ratio | Accept 1.0+ | Require 2.0+ |[m
[32m+[m[32m| Max Drawdown | Accept 20%+ | Max 10% |[m
[32m+[m[32m| Alpha Decay | Not measured | Track half-life |[m
[32m+[m[32m| Regime Consistency | Not measured | Must work in all regimes |[m
[32m+[m[32m| Conviction Calibration | Not measured | High confidence = high accuracy |[m
[32m+[m[32m| Crowding Score | Not measured | Penalize popular strategies |[m
[32m+[m[32m| Black Swan Survival | Not measured | Must survive tail events |[m
[32m+[m
[32m+[m[32m### Grade Levels[m
[32m+[m
[32m+[m[32m| Grade | Score | Meaning |[m
[32m+[m[32m|-------|-------|---------|[m
[32m+[m[32m| ELITE | 85+ | Ready for live capital |[m
[32m+[m[32m| BATTLE_READY | 70-84 | Paper trading approved |[m
[32m+[m[32m| DEVELOPING | 50-69 | Continue training |[m
[32m+[m[32m| INADEQUATE | 30-49 | Needs major work |[m
[32m+[m[32m| FAILED | <30 | Critical flaws, rebuild |[m
[32m+[m
[32m+[m[32m### Unique Features We Measure[m
[32m+[m
[32m+[m[32m1. **Alpha Half-Life** - How long does the edge last? (min 30 days)[m
[32m+[m[32m2. **Regime Consistency** - Profitable in bull, bear, sideways? (70%+ of regimes)[m
[32m+[m[32m3. **Conviction-Accuracy Correlation** - When 90% confident, 90% accurate? (0.6+ correlation)[m
[32m+[m[32m4. **Crowding Score** - Is everyone doing this? (max 30% crowded)[m
[32m+[m[32m5. **Black Swan Survival** - Performance during crashes? (80%+ survival)[m
[32m+[m[32m6. **Reflexivity Score** - Does trading affect the market? (max 5% impact)[m
[32m+[m[32m7. **Capacity Estimate** - How much AUM before alpha decays? (min $10M)[m
[32m+[m
[32m+[m[32m---[m
[32m+[m
[32m+[m[32m## RUNNING SCRIPTS[m
[32m+[m
[32m+[m[32m### Windows Batch Files (Double-Click)[m
[32m+[m
[32m+[m[32m| File | Purpose |[m
[32m+[m[32m|------|---------|[m
[32m+[m[32m| `scripts/TRAIN_ALL_AGENTS.bat` | Train all agents with elite grading |[m
[32m+[m[32m| `scripts/HYDRATE_ALPHA_VANTAGE.bat` | Pull Alpha Vantage data |[m
[32m+[m[32m| `scripts/INGEST_RESEARCH.bat` | Ingest research documents |[m
[32m+[m[32m| `scripts/CHECK_MODEL_GRADES.bat` | View model performance |[m
[32m+[m[32m| `scripts/START_PAPER_TRADING.bat` | Start paper trading |[m
[32m+[m
[32m+[m[32m### Manual Commands[m
[32m+[m
[32m+[m[32m```powershell[m
[32m+[m[32m# Data Collection[m
[32m+[m[32mpython scripts/hydrate_full_universe.py          # All Polygon data[m
[32m+[m[32mpython scripts/hydrate_alpha_vantage.py --quick  # Quick AV test[m
[32m+[m[32mpython scripts/ingest_research.py                # Research docs[m
[32m+[m
[32m+[m[32m# Training[m
[32m+[m[32mpython -m src.training.agent_trainer --all       # All agents[m
[32m+[m[32mpython -m src.ml.advanced_training               # ML models[m
[32m+[m
[32m+[m[32m# Trading[m
[32m+[m[32mpython scripts/model_dashboard.py                # View grades[m
[32m+[m[32m```[m
[32m+[m
[32m+[m[32m---[m
[32m+[m
[32m+[m[32m## MONITORING & DASHBOARDS[m
[32m+[m
[32m+[m[32m### Log Files[m
[32m+[m
[32m+[m[32m| Log | Location | Purpose |[m
[32m+[m[32m|-----|----------|---------|[m
[32m+[m[32m| Training | `logs/agent_training.log` | Agent training progress |[m
[32m+[m[32m| Hydration | `logs/hydration.log` | Data collection |[m
[32m+[m[32m| Alpha Vantage | `logs/alpha_vantage_hydration.log` | AV specific |[m
[32m+[m[32m| Research | `logs/ingest_research.log` | Document ingestion |[m
[32m+[m
[32m+[m[32m### Check Training Progress[m
[32m+[m
[32m+[m[32m```powershell[m
[32m+[m[32m# View latest training results[m
[32m+[m[32mGet-Content data/training_results/*.json | ConvertFrom-Json | Format-Table[m
[32m+[m
[32m+[m[32m# Watch log in real-time[m
[32m+[m[32mGet-Content logs/agent_training.log -Wait -Tail 50[m
[32m+[m
[32m+[m[32m# Count promoted agents[m
[32m+[m[32m(Get-Content data/training_results/*.json | ConvertFrom-Json | Where-Object {$_.passed_elite}).Count[m
[32m+[m[32m```[m
[32m+[m
[32m+[m[32m### Dashboard[m
[32m+[m
[32m+[m[32m```powershell[m
[32m+[m[32mpython scripts/model_dashboard.py[m
[32m+[m[32m```[m
[32m+[m
[32m+[m[32m---[m
[32m+[m
[32m+[m[32m## TROUBLESHOOTING[m
[32m+[m
[32m+[m[32m### API Key Issues[m
[32m+[m
[32m+[m[32m```[m
[32m+[m[32mError: Polygon API Key: MISSING[m
[32m+[m[32m```[m
[32m+[m[32mSolution: Check your `.env` file has `PolygonIO_API_KEY=your_key`[m
[32m+[m
[32m+[m[32m### SQL Connection Issues[m
[32m+[m
[32m+[m[32m```[m
[32m+[m[32mError: Could not open a connection to SQL Server[m
[32m+[m[32m```[m
[32m+[m[32mSolutions:[m
[32m+[m[32m1. Check SQL server name ends with `.database.windows.net`[m
[32m+[m[32m2. Check firewall allows your IP[m
[32m+[m[32m3. Verify credentials in settings[m
[32m+[m
[32m+[m[32m### Import Errors[m
[32m+[m
[32m+[m[32m```[m
[32m+[m[32mError: ModuleNotFoundError: No module named 'xxx'[m
[32m+[m[32m```[m
[32m+[m[32mSolution:[m
[32m+[m[32m```powershell[m
[32m+[m[32m.\venv\Scripts\activate[m
[32m+[m[32mpip install -r requirements.txt[m
[32m+[m[32m```[m
[32m+[m
[32m+[m[32m### Training Fails with No Data[m
[32m+[m
[32m+[m[32m```[m
[32m+[m[32mError: No training data available[m
[32m+[m[32m```[m
[32m+[m[32mSolution: Run data hydration first:[m
[32m+[m[32m```powershell[m
[32m+[m[32mpython scripts/hydrate_full_universe.py --quick[m
[32m+[m[32m```[m
[32m+[m
[32m+[m[32m---[m
[32m+[m
[32m+[m[32m## OVERNIGHT TRAINING SETUP[m
[32m+[m
[32m+[m[32m### Windows - Keep Running All Night[m
[32m+[m
[32m+[m[32m1. **Prevent Sleep:**[m
[32m+[m[32m   - Settings > System > Power > Never sleep when plugged in[m
[32m+[m
[32m+[m[32m2. **Run in Background:**[m
[32m+[m[32m   ```powershell[m
[32m+[m[32m   # Terminal 1: Data Hydration[m
[32m+[m[32m   python scripts/hydrate_full_universe.py 2>&1 | Tee-Object logs/hydration.log[m
[32m+[m
[32m+[m[32m   # Terminal 2: Agent Training[m
[32m+[m[32m   python -m src.training.agent_trainer --all 2>&1 | Tee-Object logs/training.log[m
[32m+[m
[32m+[m[32m   # Terminal 3: ML Model Training[m
[32m+[m[32m   python -c "from src.ml.advanced_training import run_overnight_training; run_overnight_training()"[m
[32m+[m[32m   ```[m
[32m+[m
[32m+[m[32m3. **Auto-Restart Script:**[m
[32m+[m[32m   ```powershell[m
[32m+[m[32m   # Save as overnight.ps1[m
[32m+[m[32m   while ($true) {[m
[32m+[m[32m       try {[m
[32m+[m[32m           python -m src.training.agent_trainer --all[m
[32m+[m[32m       } catch {[m
[32m+[m[32m           Write-Host "Error, restarting in 60s..."[m
[32m+[m[32m           Start-Sleep -Seconds 60[m
[32m+[m[32m       }[m
[32m+[m[32m   }[m
[32m+[m[32m   ```[m
[32m+[m
[32m+[m[32m### Mac - Keep Running All Night[m
[32m+[m
[32m+[m[32m1. **Prevent Sleep:**[m
[32m+[m[32m   ```bash[m
[32m+[m[32m   caffeinate -i python -m src.training.agent_trainer --all[m
[32m+[m[32m   ```[m
[32m+[m
[32m+[m[32m2. **Use tmux/screen:**[m
[32m+[m[32m   ```bash[m
[32m+[m[32m   tmux new -s training[m
[32m+[m[32m   python -m src.training.agent_trainer --all[m
[32m+[m[32m   # Ctrl+B, D to detach[m
[32m+[m[32m   # tmux attach -t training to reconnect[m
[32m+[m[32m   ```[m
[32m+[m
[32m+[m[32m---[m
[32m+[m
[32m+[m[32m## FILE REFERENCE[m
[32m+[m
[32m+[m[32m### Key Files[m
[32m+[m
[32m+[m[32m| Path | Purpose |[m
[32m+[m[32m|------|---------|[m
[32m+[m[32m| `src/config/settings.py` | All configuration |[m
[32m+[m[32m| `src/core/elite_grading.py` | Elite grading system |[m
[32m+[m[32m| `src/training/agent_trainer.py` | Agent training orchestrator |[m
[32m+[m[32m| `src/ml/advanced_training.py` | ML model training |[m
[32m+[m[32m| `src/agents/` | All 112 agent files |[m
[32m+[m
[32m+[m[32m### Data Directories[m
[32m+[m
[32m+[m[32m| Path | Contents |[m
[32m+[m[32m|------|----------|[m
[32m+[m[32m| `data/csv_backup/` | CSV backups of all data |[m
[32m+[m[32m| `data/training_results/` | Agent training results |[m
[32m+[m[32m| `data/models/` | Trained ML models |[m
[32m+[m[32m| `data/vectorstore/` | Research embeddings |[m
[32m+[m[32m| `logs/` | All log files |[m
[32m+[m
[32m+[m[32m---[m
[32m+[m
[32m+[m[32m## CONTACT[m
[32m+[m
[32m+[m[32mFor issues: Check logs first, then refer to this guide.[m
[32m+[m
[32m+[m[32mSystem designed for Alpha Loop Capital institutional trading.[m
[32m+[m
[1mdiff --git a/catboost_info/catboost_training.json b/catboost_info/catboost_training.json[m
[1mnew file mode 100644[m
[1mindex 00000000..c54deb23[m
[1m--- /dev/null[m
[1m+++ b/catboost_info/catboost_training.json[m
[36m@@ -0,0 +1,4 @@[m
[32m+[m[32m{[m
[32m+[m[32m"meta":{"test_sets":[],"test_metrics":[],"learn_metrics":[{"best_value":"Min","name":"Logloss"}],"launch_mode":"Train","parameters":"","iteration_count":800,"learn_sets":["learn"],"name":"experiment"},[m
[32m+[m[32m"iterations":[[m
[32m+[m[32m{"[m
\ No newline at end of file[m
[1mdiff --git a/catboost_info/learn/events.out.tfevents b/catboost_info/learn/events.out.tfevents[m
[1mnew file mode 100644[m
[1mindex 00000000..e69de29b[m
[1mdiff --git a/catboost_info/learn_error.tsv b/catboost_info/learn_error.tsv[m
[1mnew file mode 100644[m
[1mindex 00000000..e69de29b[m
[1mdiff --git a/catboost_info/time_left.tsv b/catboost_info/time_left.tsv[m
[1mnew file mode 100644[m
[1mindex 00000000..e69de29b[m
[1mdiff --git a/catboost_info/tmp/cat_feature_index.7ba84d0d-15899c01-e28edeec-c7bf27c.tmp b/catboost_info/tmp/cat_feature_index.7ba84d0d-15899c01-e28edeec-c7bf27c.tmp[m
[1mnew file mode 100644[m
[1mindex 00000000..593f4708[m
Binary files /dev/null and b/catboost_info/tmp/cat_feature_index.7ba84d0d-15899c01-e28edeec-c7bf27c.tmp differ
[1mdiff --git a/catboost_info/tmp/cat_feature_index.d657208d-159e5572-7185ecd0-8c7ae164.tmp b/catboost_info/tmp/cat_feature_index.d657208d-159e5572-7185ecd0-8c7ae164.tmp[m
[1mnew file mode 100644[m
[1mindex 00000000..593f4708[m
Binary files /dev/null and b/catboost_info/tmp/cat_feature_index.d657208d-159e5572-7185ecd0-8c7ae164.tmp differ
[1mdiff --git a/dfu/src/agents/killjoy_agent/killjoy_agent.py b/dfu/src/agents/killjoy_agent/killjoy_agent.py[m
[1mnew file mode 100644[m
[1mindex 00000000..4aa5b645[m
[1m--- /dev/null[m
[1m+++ b/dfu/src/agents/killjoy_agent/killjoy_agent.py[m
[36m@@ -0,0 +1,873 @@[m
[32m+[m[32m"""[m
[32m+[m[32m================================================================================[m
[32m+[m[32mKILLJOY AGENT - THE RUTHLESS RISK GUARDIAN[m
[32m+[m[32m================================================================================[m
[32m+[m[32mAuthor: Tom Hogan | Alpha Loop Capital, LLC[m
[32m+[m[32mVersion: 3.0 | December 2024[m
[32m+[m
[32m+[m[32mKILLJOY is the LAST LINE OF DEFENSE before any trade executes.[m
[32m+[m
[32m+[m[32mThis is NOT a gentle risk manager. KILLJOY has ONE JOB:[m
[32m+[m[32m    PREVENT CATASTROPHIC LOSSES AT ALL COSTS.[m
[32m+[m
[32m+[m[32mKILLJOY operates on the principle that:[m
[32m+[m[32m    "It's better to miss 100 winning trades than take 1 trade that blows up."[m
[32m+[m
[32m+[m[32mKILLJOY has VETO POWER over:[m
[32m+[m[32m    - GHOST[m
[32m+[m[32m    - HOAGS[m
[32m+[m[32m    - ALL Senior Agents[m
[32m+[m[32m    - ALL Strategy Agents[m
[32m+[m[32m    - EVERY single trade[m
[32m+[m
[32m+[m[32mOnly Tom Hogan can override KILLJOY. And even then, KILLJOY logs the override.[m
[32m+[m
[32m+[m[32mGUARDRAIL LEVELS:[m
[32m+[m[32m    - LEVEL 1: SOFT LIMIT  - Warning + Reduced size[m
[32m+[m[32m    - LEVEL 2: HARD LIMIT  - Block trade + Alert[m
[32m+[m[32m    - LEVEL 3: EMERGENCY   - Liquidate positions + Full stop[m
[32m+[m[32m    - LEVEL 4: APOCALYPSE  - Everything to cash + Human intervention required[m
[32m+[m
[32m+[m[32m"The graveyard of hedge funds is filled with those who ignored risk."[m
[32m+[m[32m================================================================================[m
[32m+[m[32m"""[m
[32m+[m
[32m+[m[32mimport logging[m
[32m+[m[32mfrom datetime import datetime, timedelta[m
[32m+[m[32mfrom typing import Dict, List, Optional, Any, Tuple[m
[32m+[m[32mfrom dataclasses import dataclass, field[m
[32m+[m[32mfrom enum import Enum[m
[32m+[m[32mimport json[m
[32m+[m
[32m+[m[32mfrom src.core.agent_base import BaseAgent, AgentTier[m
[32m+[m
[32m+[m[32mlogger = logging.getLogger(__name__)[m
[32m+[m
[32m+[m
[32m+[m[32m# =============================================================================[m
[32m+[m[32m# ENUMS & DATA STRUCTURES[m
[32m+[m[32m# =============================================================================[m
[32m+[m
[32m+[m[32mclass AlertLevel(Enum):[m
[32m+[m[32m    """Severity levels for KILLJOY alerts."""[m
[32m+[m[32m    INFO = "info"              # Logged, no action[m
[32m+[m[32m    WARNING = "warning"        # Size reduction applied[m
[32m+[m[32m    CRITICAL = "critical"      # Trade blocked[m
[32m+[m[32m    EMERGENCY = "emergency"    # Positions liquidated[m
[32m+[m[32m    APOCALYPSE = "apocalypse"  # Full stop, human required[m
[32m+[m
[32m+[m
[32m+[m[32mclass RiskCategory(Enum):[m
[32m+[m[32m    """Categories of risk KILLJOY monitors."""[m
[32m+[m[32m    POSITION_SIZE = "position_size"[m
[32m+[m[32m    SECTOR_CONCENTRATION = "sector_concentration"[m
[32m+[m[32m    SINGLE_NAME = "single_name"[m
[32m+[m[32m    DAILY_LOSS = "daily_loss"[m
[32m+[m[32m    WEEKLY_LOSS = "weekly_loss"[m
[32m+[m[32m    MONTHLY_LOSS = "monthly_loss"[m
[32m+[m[32m    DRAWDOWN = "drawdown"[m
[32m+[m[32m    CORRELATION = "correlation"[m
[32m+[m[32m    LIQUIDITY = "liquidity"[m
[32m+[m[32m    VOLATILITY = "volatility"[m
[32m+[m[32m    LEVERAGE = "leverage"[m
[32m+[m[32m    VAR = "value_at_risk"[m
[32m+[m[32m    EXPOSURE = "exposure"[m
[32m+[m[32m    HEAT = "heat"[m
[32m+[m
[32m+[m
[32m+[m[32m@dataclass[m
[32m+[m[32mclass RiskLimit:[m
[32m+[m[32m    """A single risk limit with soft and hard thresholds."""[m
[32m+[m[32m    category: RiskCategory[m
[32m+[m[32m    soft_limit: float       # Warning threshold[m
[32m+[m[32m    hard_limit: float       # Block threshold[m[41m  [m
[32m+[m[32m    emergency_limit: float  # Liquidation threshold[m
[32m+[m[32m    current_value: float = 0.0[m
[32m+[m[32m    last_checked: datetime = field(default_factory=datetime.now)[m
[32m+[m[32m    breaches_today: int = 0[m
[32m+[m[41m    [m
[32m+[m[32m    @property[m
[32m+[m[32m    def status(self) -> AlertLevel:[m
[32m+[m[32m        if self.current_value >= self.emergency_limit:[m
[32m+[m[32m            return AlertLevel.EMERGENCY[m
[32m+[m[32m        elif self.current_value >= self.hard_limit:[m
[32m+[m[32m            return AlertLevel.CRITICAL[m
[32m+[m[32m        elif self.current_value >= self.soft_limit:[m
[32m+[m[32m            return AlertLevel.WARNING[m
[32m+[m[32m        return AlertLevel.INFO[m
[32m+[m[41m    [m
[32m+[m[32m    def to_dict(self) -> Dict:[m
[32m+[m[32m        return {[m
[32m+[m[32m            "category": self.category.value,[m
[32m+[m[32m            "soft_limit": self.soft_limit,[m
[32m+[m[32m            "hard_limit": self.hard_limit,[m
[32m+[m[32m            "emergency_limit": self.emergency_limit,[m
[32m+[m[32m            "current_value": self.current_value,[m
[32m+[m[32m            "status": self.status.value,[m
[32m+[m[32m            "breaches_today": self.breaches_today,[m
[32m+[m[32m        }[m
[32m+[m
[32m+[m
[32m+[m[32m@dataclass[m
[32m+[m[32mclass TradeRequest:[m
[32m+[m[32m    """A trade request submitted for KILLJOY approval."""[m
[32m+[m[32m    request_id: str[m
[32m+[m[32m    agent_id: str[m
[32m+[m[32m    agent_name: str[m
[32m+[m[32m    symbol: str[m
[32m+[m[32m    action: str  # BUY, SELL, SHORT, COVER[m
[32m+[m[32m    quantity: int[m
[32m+[m[32m    price: float[m
[32m+[m[32m    order_type: str[m
[32m+[m[32m    confidence: float[m
[32m+[m[32m    reasoning: str[m
[32m+[m[32m    timestamp: datetime = field(default_factory=datetime.now)[m
[32m+[m[41m    [m
[32m+[m[32m    @property[m
[32m+[m[32m    def notional_value(self) -> float:[m
[32m+[m[32m        return self.quantity * self.price[m
[32m+[m
[32m+[m
[32m+[m[32m@dataclass[m
[32m+[m[32mclass TradeVerdict:[m
[32m+[m[32m    """KILLJOY's verdict on a trade request."""[m
[32m+[m[32m    request_id: str[m
[32m+[m[32m    approved: bool[m
[32m+[m[32m    original_quantity: int[m
[32m+[m[32m    approved_quantity: int[m
[32m+[m[32m    alert_level: AlertLevel[m
[32m+[m[32m    reasons: List[str][m
[32m+[m[32m    adjustments: List[str][m
[32m+[m[32m    risk_score: float  # 0-100[m
[32m+[m[32m    timestamp: datetime = field(default_factory=datetime.now)[m
[32m+[m[41m    [m
[32m+[m[32m    def to_dict(self) -> Dict:[m
[32m+[m[32m        return {[m
[32m+[m[32m            "request_id": self.request_id,[m
[32m+[m[32m            "approved": self.approved,[m
[32m+[m[32m            "original_quantity": self.original_quantity,[m
[32m+[m[32m            "approved_quantity": self.approved_quantity,[m
[32m+[m[32m            "alert_level": self.alert_level.value,[m
[32m+[m[32m            "reasons": self.reasons,[m
[32m+[m[32m            "adjustments": self.adjustments,[m
[32m+[m[32m            "risk_score": self.risk_score,[m
[32m+[m[32m            "timestamp": self.timestamp.isoformat(),[m
[32m+[m[32m        }[m
[32m+[m
[32m+[m
[32m+[m[32m@dataclass[m
[32m+[m[32mclass PortfolioState:[m
[32m+[m[32m    """Current state of the portfolio for risk assessment."""[m
[32m+[m[32m    total_equity: float = 1_000_000.0  # $1M default[m
[32m+[m[32m    cash: float = 500_000.0[m
[32m+[m[32m    positions: Dict[str, Dict] = field(default_factory=dict)[m
[32m+[m[41m    [m
[32m+[m[32m    # Daily P&L[m
[32m+[m[32m    daily_pnl: float = 0.0[m
[32m+[m[32m    daily_pnl_pct: float = 0.0[m
[32m+[m[41m    [m
[32m+[m[32m    # Weekly/Monthly[m
[32m+[m[32m    weekly_pnl: float = 0.0[m
[32m+[m[32m    monthly_pnl: float = 0.0[m
[32m+[m[41m    [m
[32m+[m[32m    # Drawdown[m
[32m+[m[32m    peak_equity: float = 1_000_000.0[m
[32m+[m[32m    current_drawdown: float = 0.0[m
[32m+[m[32m    max_drawdown: float = 0.0[m
[32m+[m[41m    [m
[32m+[m[32m    # Exposure[m
[32m+[m[32m    gross_exposure: float = 0.0[m
[32m+[m[32m    net_exposure: float = 0.0[m
[32m+[m[32m    long_exposure: float = 0.0[m
[32m+[m[32m    short_exposure: float = 0.0[m
[32m+[m[41m    [m
[32m+[m[32m    # Sector breakdown[m
[32m+[m[32m    sector_exposures: Dict[str, float] = field(default_factory=dict)[m
[32m+[m[41m    [m
[32m+[m[32m    # Risk metrics[m
[32m+[m[32m    portfolio_var: float = 0.0  # Value at Risk[m
[32m+[m[32m    portfolio_vol: float = 0.0  # Volatility[m
[32m+[m[32m    beta: float = 1.0[m
[32m+[m[41m    [m
[32m+[m[32m    # Heat (recent losses)[m
[32m+[m[32m    heat_level: float = 0.0  # 0-100[m
[32m+[m[32m    consecutive_losses: int = 0[m
[32m+[m
[32m+[m
[32m+[m[32m# =============================================================================[m
[32m+[m[32m# THE KILLJOY AGENT[m
[32m+[m[32m# =============================================================================[m
[32m+[m
[32m+[m[32mclass KilljoyAgent(BaseAgent):[m
[32m+[m[32m    """[m
[32m+[m[32m    KILLJOY - The Ruthless Risk Guardian[m
[32m+[m[41m    [m
[32m+[m[32m    KILLJOY has ABSOLUTE VETO POWER over every trade in the system.[m
[32m+[m[41m    [m
[32m+[m[32m    It enforces:[m
[32m+[m[32m    1. POSITION LIMITS - No single position > 5% of portfolio[m
[32m+[m[32m    2. SECTOR LIMITS - No sector > 25% of portfolio[m
[32m+[m[32m    3. DAILY LOSS LIMIT - Stop trading at 2% daily loss[m
[32m+[m[32m    4. WEEKLY LOSS LIMIT - Reduce size at 5% weekly loss[m
[32m+[m[32m    5. MONTHLY LOSS LIMIT - Emergency at 10% monthly loss[m
[32m+[m[32m    6. DRAWDOWN PROTECTION - Liquidate at 15% drawdown[m
[32m+[m[32m    7. LEVERAGE LIMIT - Max 2x gross exposure[m
[32m+[m[32m    8. LIQUIDITY REQUIREMENTS - Can't be >10% of daily volume[m
[32m+[m[32m    9. CORRELATION LIMITS - Max 0.7 correlation between positions[m
[32m+[m[32m    10. HEAT MANAGEMENT - Reduce size after consecutive losses[m
[32m+[m[41m    [m
[32m+[m[32m    Key Methods:[m
[32m+[m[32m    - approve_trade(): THE GATEKEEPER - every trade goes through here[m
[32m+[m[32m    - check_portfolio_risk(): Real-time portfolio risk assessment[m
[32m+[m[32m    - enforce_limits(): Apply guardrails[m
[32m+[m[32m    - emergency_liquidate(): Nuclear option[m
[32m+[m[32m    """[m
[32m+[m[41m    [m
[32m+[m[32m    # =========================================================================[m
[32m+[m[32m    # INSTITUTIONAL-GRADE RISK LIMITS[m
[32m+[m[32m    # =========================================================================[m
[32m+[m[41m    [m
[32m+[m[32m    # Position Limits[m
[32m+[m[32m    MAX_POSITION_PCT = 0.05          # 5% max single position[m
[32m+[m[32m    MAX_POSITION_PCT_SOFT = 0.03     # 3% soft limit (warning)[m
[32m+[m[41m    [m
[32m+[m[32m    # Sector Limits[m
[32m+[m[32m    MAX_SECTOR_PCT = 0.25            # 25% max sector exposure[m
[32m+[m[32m    MAX_SECTOR_PCT_SOFT = 0.20       # 20% soft limit[m
[32m+[m[41m    [m
[32m+[m[32m    # Loss Limits[m
[32m+[m[32m    DAILY_LOSS_LIMIT = 0.02          # 2% daily loss = stop trading[m
[32m+[m[32m    DAILY_LOSS_SOFT = 0.01           # 1% = reduce size[m
[32m+[m[32m    WEEKLY_LOSS_LIMIT = 0.05         # 5% weekly loss = emergency[m
[32m+[m[32m    WEEKLY_LOSS_SOFT = 0.03          # 3% = serious reduction[m
[32m+[m[32m    MONTHLY_LOSS_LIMIT = 0.10        # 10% monthly = human intervention[m
[32m+[m[32m    MONTHLY_LOSS_SOFT = 0.07         # 7% = minimal trading[m
[32m+[m[41m    [m
[32m+[m[32m    # Drawdown Limits[m
[32m+[m[32m    MAX_DRAWDOWN = 0.15              # 15% drawdown = liquidate[m
[32m+[m[32m    MAX_DRAWDOWN_SOFT = 0.10         # 10% = major reduction[m
[32m+[m[32m    MAX_DRAWDOWN_WARN = 0.05         # 5% = start reducing[m
[32m+[m[41m    [m
[32m+[m[32m    # Leverage Limits[m
[32m+[m[32m    MAX_GROSS_EXPOSURE = 2.0         # 200% max[m
[32m+[m[32m    MAX_NET_EXPOSURE = 1.0           # 100% max net[m
[32m+[m[41m    [m
[32m+[m[32m    # Liquidity Limits[m
[32m+[m[32m    MAX_VOLUME_PCT = 0.10            # Can't be >10% of daily volume[m
[32m+[m[41m    [m
[32m+[m[32m    # Heat Limits[m
[32m+[m[32m    MAX_CONSECUTIVE_LOSSES = 5       # After 5 losses, stop trading[m
[32m+[m[32m    HEAT_REDUCTION_THRESHOLD = 50    # Heat > 50 = reduce size[m
[32m+[m[41m    [m
[32m+[m[32m    # VAR Limit[m
[32m+[m[32m    MAX_VAR_PCT = 0.02               # 2% daily VaR limit[m
[32m+[m[41m    [m
[32m+[m[32m    def __init__(self, user_id: str = "TJH"):[m
[32m+[m[32m        super().__init__([m
[32m+[m[32m            name="KILLJOY",[m
[32m+[m[32m            tier=AgentTier.SENIOR,[m
[32m+[m[32m            capabilities=[[m
[32m+[m[32m                # Core risk management[m
[32m+[m[32m                "trade_approval",[m
[32m+[m[32m                "position_limit_enforcement",[m
[32m+[m[32m                "sector_limit_enforcement",[m
[32m+[m[32m                "loss_limit_enforcement",[m
[32m+[m[32m                "drawdown_protection",[m
[32m+[m[32m                "leverage_control",[m
[32m+[m[32m                "liquidity_monitoring",[m
[32m+[m[32m                "correlation_analysis",[m
[32m+[m[32m                "heat_management",[m
[32m+[m[32m                "var_calculation",[m
[32m+[m[41m                [m
[32m+[m[32m                # Emergency actions[m
[32m+[m[32m                "emergency_liquidation",[m
[32m+[m[32m                "trading_halt",[m
[32m+[m[32m                "position_reduction",[m
[32m+[m[32m                "exposure_hedging",[m
[32m+[m[41m                [m
[32m+[m[32m                # Monitoring[m
[32m+[m[32m                "real_time_risk_monitoring",[m
[32m+[m[32m                "pnl_tracking",[m
[32m+[m[32m                "limit_breach_alerting",[m
[32m+[m[32m                "risk_reporting",[m
[32m+[m[41m                [m
[32m+[m[32m                # Authority[m
[32m+[m[32m                "veto_power",[m
[32m+[m[32m                "override_logging",[m
[32m+[m[32m                "hoags_escalation",[m
[32m+[m[32m            ],[m
[32m+[m[32m            user_id=user_id,[m
[32m+[m[32m        )[m
[32m+[m[41m        [m
[32m+[m[32m        # Portfolio state[m
[32m+[m[32m        self.portfolio = PortfolioState()[m
[32m+[m[41m        [m
[32m+[m[32m        # Initialize risk limits[m
[32m+[m[32m        self.limits = self._init_limits()[m
[32m+[m[41m        [m
[32m+[m[32m        # Trade history[m
[32m+[m[32m        self.approved_trades: List[TradeVerdict] = [][m
[32m+[m[32m        self.blocked_trades: List[TradeVerdict] = [][m
[32m+[m[32m        self.alerts_issued: List[Dict] = [][m
[32m+[m[41m        [m
[32m+[m[32m        # Statistics[m
[32m+[m[32m        self.trades_reviewed = 0[m
[32m+[m[32m        self.trades_approved = 0[m
[32m+[m[32m        self.trades_blocked = 0[m
[32m+[m[32m        self.trades_reduced = 0[m
[32m+[m[32m        self.emergency_liquidations = 0[m
[32m+[m[41m        [m
[32m+[m[32m        # State[m
[32m+[m[32m        self.trading_halted = False[m
[32m+[m[32m        self.halt_reason = ""[m
[32m+[m[32m        self.human_intervention_required = False[m
[32m+[m[41m        [m
[32m+[m[32m        logger.info("ðŸ›¡ï¸ KILLJOY initialized - THE RISK GUARDIAN IS WATCHING")[m
[32m+[m[41m    [m
[32m+[m[32m    def _init_limits(self) -> Dict[RiskCategory, RiskLimit]:[m
[32m+[m[32m        """Initialize all risk limits."""[m
[32m+[m[32m        return {[m
[32m+[m[32m            RiskCategory.POSITION_SIZE: RiskLimit([m
[32m+[m[32m                category=RiskCategory.POSITION_SIZE,[m
[32m+[m[32m                soft_limit=self.MAX_POSITION_PCT_SOFT,[m
[32m+[m[32m                hard_limit=self.MAX_POSITION_PCT,[m
[32m+[m[32m                emergency_limit=self.MAX_POSITION_PCT * 1.5[m
[32m+[m[32m            ),[m
[32m+[m[32m            RiskCategory.SECTOR_CONCENTRATION: RiskLimit([m
[32m+[m[32m                category=RiskCategory.SECTOR_CONCENTRATION,[m
[32m+[m[32m                soft_limit=self.MAX_SECTOR_PCT_SOFT,[m
[32m+[m[32m                hard_limit=self.MAX_SECTOR_PCT,[m
[32m+[m[32m                emergency_limit=self.MAX_SECTOR_PCT * 1.2[m
[32m+[m[32m            ),[m
[32m+[m[32m            RiskCategory.DAILY_LOSS: RiskLimit([m
[32m+[m[32m                category=RiskCategory.DAILY_LOSS,[m
[32m+[m[32m                soft_limit=self.DAILY_LOSS_SOFT,[m
[32m+[m[32m                hard_limit=self.DAILY_LOSS_LIMIT,[m
[32m+[m[32m                emergency_limit=self.DAILY_LOSS_LIMIT * 1.5[m
[32m+[m[32m            ),[m
[32m+[m[32m            RiskCategory.WEEKLY_LOSS: RiskLimit([m
[32m+[m[32m                category=RiskCategory.WEEKLY_LOSS,[m
[32m+[m[32m                soft_limit=self.WEEKLY_LOSS_SOFT,[m
[32m+[m[32m                hard_limit=self.WEEKLY_LOSS_LIMIT,[m
[32m+[m[32m                emergency_limit=self.WEEKLY_LOSS_LIMIT * 1.5[m
[32m+[m[32m            ),[m
[32m+[m[32m            RiskCategory.MONTHLY_LOSS: RiskLimit([m
[32m+[m[32m                category=RiskCategory.MONTHLY_LOSS,[m
[32m+[m[32m                soft_limit=self.MONTHLY_LOSS_SOFT,[m
[32m+[m[32m                hard_limit=self.MONTHLY_LOSS_LIMIT,[m
[32m+[m[32m                emergency_limit=self.MONTHLY_LOSS_LIMIT * 1.5[m
[32m+[m[32m            ),[m
[32m+[m[32m            RiskCategory.DRAWDOWN: RiskLimit([m
[32m+[m[32m                category=RiskCategory.DRAWDOWN,[m
[32m+[m[32m                soft_limit=self.MAX_DRAWDOWN_WARN,[m
[32m+[m[32m                hard_limit=self.MAX_DRAWDOWN_SOFT,[m
[32m+[m[32m                emergency_limit=self.MAX_DRAWDOWN[m
[32m+[m[32m            ),[m
[32m+[m[32m            RiskCategory.LEVERAGE: RiskLimit([m
[32m+[m[32m                category=RiskCategory.LEVERAGE,[m
[32m+[m[32m                soft_limit=self.MAX_GROSS_EXPOSURE * 0.8,[m
[32m+[m[32m                hard_limit=self.MAX_GROSS_EXPOSURE,[m
[32m+[m[32m                emergency_limit=self.MAX_GROSS_EXPOSURE * 1.2[m
[32m+[m[32m            ),[m
[32m+[m[32m            RiskCategory.VAR: RiskLimit([m
[32m+[m[32m                category=RiskCategory.VAR,[m
[32m+[m[32m                soft_limit=self.MAX_VAR_PCT * 0.7,[m
[32m+[m[32m                hard_limit=self.MAX_VAR_PCT,[m
[32m+[m[32m                emergency_limit=self.MAX_VAR_PCT * 1.5[m
[32m+[m[32m            ),[m
[32m+[m[32m            RiskCategory.HEAT: RiskLimit([m
[32m+[m[32m                category=RiskCategory.HEAT,[m
[32m+[m[32m                soft_limit=self.HEAT_REDUCTION_THRESHOLD,[m
[32m+[m[32m                hard_limit=75,[m
[32m+[m[32m                emergency_limit=90[m
[32m+[m[32m            ),[m
[32m+[m[32m        }[m
[32m+[m[41m    [m
[32m+[m[32m    # =========================================================================[m
[32m+[m[32m    # CORE RISK METHODS[m
[32m+[m[32m    # =========================================================================[m
[32m+[m[41m    [m
[32m+[m[32m    def process(self, task: Dict[str, Any]) -> Dict[str, Any]:[m
[32m+[m[32m        """Process a KILLJOY task."""[m
[32m+[m[32m        action = task.get("action", task.get("type", ""))[m
[32m+[m[32m        params = task.get("parameters", task)[m
[32m+[m[41m        [m
[32m+[m[32m        self.log_action(action, f"KILLJOY processing: {action}")[m
[32m+[m[41m        [m
[32m+[m[32m        handlers = {[m
[32m+[m[32m            "approve_trade": self._handle_approve_trade,[m
[32m+[m[32m            "check_risk": self._handle_check_risk,[m
[32m+[m[32m            "update_portfolio": self._handle_update_portfolio,[m
[32m+[m[32m            "get_limits": self._handle_get_limits,[m
[32m+[m[32m            "get_status": self._handle_get_status,[m
[32m+[m[32m            "emergency_stop": self._handle_emergency_stop,[m
[32m+[m[32m            "reset_daily": self._handle_reset_daily,[m
[32m+[m[32m            "override": self._handle_override,[m
[32m+[m[32m        }[m
[32m+[m[41m        [m
[32m+[m[32m        handler = handlers.get(action, self._handle_unknown)[m
[32m+[m[32m        return handler(params)[m
[32m+[m[41m    [m
[32m+[m[32m    def get_capabilities(self) -> List[str]:[m
[32m+[m[32m        return self.capabilities[m
[32m+[m[41m    [m
[32m+[m[32m    def approve_trade(self, request: TradeRequest) -> TradeVerdict:[m
[32m+[m[32m        """[m
[32m+[m[32m        THE GATEKEEPER - Every single trade must pass through here.[m
[32m+[m[41m        [m
[32m+[m[32m        This is the CRITICAL function. KILLJOY reviews:[m
[32m+[m[32m        1. Is trading halted?[m
[32m+[m[32m        2. Would this breach position limits?[m
[32m+[m[32m        3. Would this breach sector limits?[m
[32m+[m[32m        4. Are we at daily/weekly/monthly loss limits?[m
[32m+[m[32m        5. Are we in drawdown territory?[m
[32m+[m[32m        6. Is leverage acceptable?[m
[32m+[m[32m        7. Is there enough liquidity?[m
[32m+[m[32m        8. Is the heat too high?[m
[32m+[m[32m        9. Is confidence sufficient?[m
[32m+[m[41m        [m
[32m+[m[32m        Returns TradeVerdict with approval status and any size adjustments.[m
[32m+[m[32m        """[m
[32m+[m[32m        self.trades_reviewed += 1[m
[32m+[m[41m        [m
[32m+[m[32m        reasons = [][m
[32m+[m[32m        adjustments = [][m
[32m+[m[32m        approved_quantity = request.quantity[m
[32m+[m[32m        alert_level = AlertLevel.INFO[m
[32m+[m[32m        risk_score = 0.0[m
[32m+[m[41m        [m
[32m+[m[32m        # =================================================================[m
[32m+[m[32m        # CHECK 0: Is trading halted?[m
[32m+[m[32m        # =================================================================[m
[32m+[m[32m        if self.trading_halted:[m
[32m+[m[32m            return TradeVerdict([m
[32m+[m[32m                request_id=request.request_id,[m
[32m+[m[32m                approved=False,[m
[32m+[m[32m                original_quantity=request.quantity,[m
[32m+[m[32m                approved_quantity=0,[m
[32m+[m[32m                alert_level=AlertLevel.CRITICAL,[m
[32m+[m[32m                reasons=[f"TRADING HALTED: {self.halt_reason}"],[m
[32m+[m[32m                adjustments=[],[m
[32m+[m[32m                risk_score=100,[m
[32m+[m[32m            )[m
[32m+[m[41m        [m
[32m+[m[32m        # =================================================================[m
[32m+[m[32m        # CHECK 1: Position Size Limit[m
[32m+[m[32m        # =================================================================[m
[32m+[m[32m        position_pct = (request.notional_value / self.portfolio.total_equity)[m
[32m+[m[32m        existing_position = self.portfolio.positions.get(request.symbol, {}).get("value", 0)[m
[32m+[m[32m        total_position_pct = (existing_position + request.notional_value) / self.portfolio.total_equity[m
[32m+[m[41m        [m
[32m+[m[32m        if total_position_pct > self.MAX_POSITION_PCT:[m
[32m+[m[32m            max_allowed = self.MAX_POSITION_PCT * self.portfolio.total_equity - existing_position[m
[32m+[m[32m            if max_allowed <= 0:[m
[32m+[m[32m                reasons.append(f"BLOCKED: Position {request.symbol} already at max ({total_position_pct:.1%})")[m
[32m+[m[32m                approved_quantity = 0[m
[32m+[m[32m                alert_level = AlertLevel.CRITICAL[m
[32m+[m[32m            else:[m
[32m+[m[32m                approved_quantity = int(max_allowed / request.price)[m
[32m+[m[32m                adjustments.append(f"REDUCED: {request.quantity} â†’ {approved_quantity} (position limit)")[m
[32m+[m[32m                alert_level = AlertLevel.WARNING[m
[32m+[m[32m            risk_score += 30[m
[32m+[m[32m        elif total_position_pct > self.MAX_POSITION_PCT_SOFT:[m
[32m+[m[32m            adjustments.append(f"WARNING: Position will be {total_position_pct:.1%} of portfolio")[m
[32m+[m[32m            alert_level = AlertLevel.WARNING[m
[32m+[m[32m            risk_score += 15[m
[32m+[m[41m        [m
[32m+[m[32m        # =================================================================[m
[32m+[m[32m        # CHECK 2: Daily Loss Limit[m
[32m+[m[32m        # =================================================================[m
[32m+[m[32m        daily_loss_pct = abs(min(0, self.portfolio.daily_pnl_pct))[m
[32m+[m[41m        [m
[32m+[m[32m        if daily_loss_pct >= self.DAILY_LOSS_LIMIT:[m
[32m+[m[32m            reasons.append(f"BLOCKED: Daily loss limit reached ({daily_loss_pct:.1%})")[m
[32m+[m[32m            approved_quantity = 0[m
[32m+[m[32m            alert_level = AlertLevel.CRITICAL[m
[32m+[m[32m            self._halt_trading("Daily loss limit reached")[m
[32m+[m[32m            risk_score += 50[m
[32m+[m[32m        elif daily_loss_pct >= self.DAILY_LOSS_SOFT:[m
[32m+[m[32m            reduction = 0.5  # Reduce size by 50%[m
[32m+[m[32m            approved_quantity = int(approved_quantity * reduction)[m
[32m+[m[32m            adjustments.append(f"REDUCED 50%: Daily loss at {daily_loss_pct:.1%}")[m
[32m+[m[32m            alert_level = AlertLevel.WARNING[m
[32m+[m[32m            risk_score += 25[m
[32m+[m[41m        [m
[32m+[m[32m        # =================================================================[m
[32m+[m[32m        # CHECK 3: Drawdown Limit[m
[32m+[m[32m        # =================================================================[m
[32m+[m[32m        if self.portfolio.current_drawdown >= self.MAX_DRAWDOWN:[m
[32m+[m[32m            reasons.append(f"BLOCKED: Max drawdown reached ({self.portfolio.current_drawdown:.1%})")[m
[32m+[m[32m            approved_quantity = 0[m
[32m+[m[32m            alert_level = AlertLevel.EMERGENCY[m
[32m+[m[32m            self._emergency_liquidate("Max drawdown breached")[m
[32m+[m[32m            risk_score += 50[m
[32m+[m[32m        elif self.portfolio.current_drawdown >= self.MAX_DRAWDOWN_SOFT:[m
[32m+[m[32m            reduction = 0.25  # Only 25% of normal size[m
[32m+[m[32m            approved_quantity = int(approved_quantity * reduction)[m
[32m+[m[32m            adjustments.append(f"REDUCED 75%: Drawdown at {self.portfolio.current_drawdown:.1%}")[m
[32m+[m[32m            alert_level = AlertLevel.CRITICAL[m
[32m+[m[32m            risk_score += 35[m
[32m+[m[32m        elif self.portfolio.current_drawdown >= self.MAX_DRAWDOWN_WARN:[m
[32m+[m[32m            reduction = 0.5[m
[32m+[m[32m            approved_quantity = int(approved_quantity * reduction)[m
[32m+[m[32m            adjustments.append(f"REDUCED 50%: Drawdown warning ({self.portfolio.current_drawdown:.1%})")[m
[32m+[m[32m            alert_level = AlertLevel.WARNING[m
[32m+[m[32m            risk_score += 20[m
[32m+[m[41m        [m
[32m+[m[32m        # =================================================================[m
[32m+[m[32m        # CHECK 4: Leverage Limit[m
[32m+[m[32m        # =================================================================[m
[32m+[m[32m        new_gross = self.portfolio.gross_exposure + request.notional_value[m
[32m+[m[32m        new_gross_pct = new_gross / self.portfolio.total_equity[m
[32m+[m[41m        [m
[32m+[m[32m        if new_gross_pct > self.MAX_GROSS_EXPOSURE:[m
[32m+[m[32m            reasons.append(f"BLOCKED: Leverage would exceed {self.MAX_GROSS_EXPOSURE:.0%}")[m
[32m+[m[32m            approved_quantity = 0[m
[32m+[m[32m            alert_level = AlertLevel.CRITICAL[m
[32m+[m[32m            risk_score += 30[m
[32m+[m[32m        elif new_gross_pct > self.MAX_GROSS_EXPOSURE * 0.9:[m
[32m+[m[32m            adjustments.append(f"WARNING: Leverage at {new_gross_pct:.0%}")[m
[32m+[m[32m            alert_level = AlertLevel.WARNING[m
[32m+[m[32m            risk_score += 15[m
[32m+[m[41m        [m
[32m+[m[32m        # =================================================================[m
[32m+[m[32m        # CHECK 5: Heat Level (Consecutive Losses)[m
[32m+[m[32m        # =================================================================[m
[32m+[m[32m        if self.portfolio.consecutive_losses >= self.MAX_CONSECUTIVE_LOSSES:[m
[32m+[m[32m            reasons.append(f"BLOCKED: {self.portfolio.consecutive_losses} consecutive losses - cooling off")[m
[32m+[m[32m            approved_quantity = 0[m
[32m+[m[32m            alert_level = AlertLevel.CRITICAL[m
[32m+[m[32m            risk_score += 40[m
[32m+[m[32m        elif self.portfolio.heat_level >= self.HEAT_REDUCTION_THRESHOLD:[m
[32m+[m[32m            heat_factor = 1 - (self.portfolio.heat_level / 100)[m
[32m+[m[32m            approved_quantity = int(approved_quantity * heat_factor)[m
[32m+[m[32m            adjustments.append(f"REDUCED: Heat level at {self.portfolio.heat_level:.0f}/100")[m
[32m+[m[32m            alert_level = AlertLevel.WARNING[m
[32m+[m[32m            risk_score += 20[m
[32m+[m[41m        [m
[32m+[m[32m        # =================================================================[m
[32m+[m[32m        # CHECK 6: Confidence Threshold[m
[32m+[m[32m        # =================================================================[m
[32m+[m[32m        MIN_CONFIDENCE = 0.55[m
[32m+[m[32m        if request.confidence < MIN_CONFIDENCE:[m
[32m+[m[32m            reasons.append(f"BLOCKED: Confidence {request.confidence:.1%} < {MIN_CONFIDENCE:.0%} minimum")[m
[32m+[m[32m            approved_quantity = 0[m
[32m+[m[32m            alert_level = AlertLevel.WARNING[m
[32m+[m[32m            risk_score += 20[m
[32m+[m[41m        [m
[32m+[m[32m        # =================================================================[m
[32m+[m[32m        # FINAL VERDICT[m
[32m+[m[32m        # =================================================================[m
[32m+[m[32m        approved = approved_quantity > 0[m
[32m+[m[41m        [m
[32m+[m[32m        verdict = TradeVerdict([m
[32m+[m[32m            request_id=request.request_id,[m
[32m+[m[32m            approved=approved,[m
[32m+[m[32m            original_quantity=request.quantity,[m
[32m+[m[32m            approved_quantity=approved_quantity,[m
[32m+[m[32m            alert_level=alert_level,[m
[32m+[m[32m            reasons=reasons,[m
[32m+[m[32m            adjustments=adjustments,[m
[32m+[m[32m            risk_score=min(100, risk_score),[m
[32m+[m[32m        )[m
[32m+[m[41m        [m
[32m+[m[32m        # Track statistics[m
[32m+[m[32m        if approved:[m
[32m+[m[32m            self.trades_approved += 1[m
[32m+[m[32m            if approved_quantity < request.quantity:[m
[32m+[m[32m                self.trades_reduced += 1[m
[32m+[m[32m            self.approved_trades.append(verdict)[m
[32m+[m[32m        else:[m
[32m+[m[32m            self.trades_blocked += 1[m
[32m+[m[32m            self.blocked_trades.append(verdict)[m
[32m+[m[41m        [m
[32m+[m[32m        # Log the decision[m
[32m+[m[32m        if not approved:[m
[32m+[m[32m            logger.warning(f"ðŸ›‘ KILLJOY BLOCKED: {request.symbol} - {reasons}")[m
[32m+[m[32m        elif adjustments:[m
[32m+[m[32m            logger.info(f"âš ï¸ KILLJOY ADJUSTED: {request.symbol} - {adjustments}")[m
[32m+[m[32m        else:[m
[32m+[m[32m            logger.info(f"âœ… KILLJOY APPROVED: {request.symbol} x{approved_quantity}")[m
[32m+[m[41m        [m
[32m+[m[32m        return verdict[m
[32m+[m[41m    [m
[32m+[m[32m    def check_portfolio_risk(self) -> Dict[str, Any]:[m
[32m+[m[32m        """[m
[32m+[m[32m        Real-time portfolio risk assessment.[m
[32m+[m[41m        [m
[32m+[m[32m        Returns comprehensive risk metrics and any limit breaches.[m
[32m+[m[32m        """[m
[32m+[m[32m        breaches = [][m
[32m+[m[32m        warnings = [][m
[32m+[m[41m        [m
[32m+[m[32m        # Update limit values[m
[32m+[m[32m        self.limits[RiskCategory.DAILY_LOSS].current_value = abs(min(0, self.portfolio.daily_pnl_pct))[m
[32m+[m[32m        self.limits[RiskCategory.WEEKLY_LOSS].current_value = abs(min(0, self.portfolio.weekly_pnl / self.portfolio.total_equity))[m
[32m+[m[32m        self.limits[RiskCategory.MONTHLY_LOSS].current_value = abs(min(0, self.portfolio.monthly_pnl / self.portfolio.total_equity))[m
[32m+[m[32m        self.limits[RiskCategory.DRAWDOWN].current_value = self.portfolio.current_drawdown[m
[32m+[m[32m        self.limits[RiskCategory.LEVERAGE].current_value = self.portfolio.gross_exposure / self.portfolio.total_equity[m
[32m+[m[32m        self.limits[RiskCategory.VAR].current_value = self.portfolio.portfolio_var[m
[32m+[m[32m        self.limits[RiskCategory.HEAT].current_value = self.portfolio.heat_level[m
[32m+[m[41m        [m
[32m+[m[32m        # Check each limit[m
[32m+[m[32m        for category, limit in self.limits.items():[m
[32m+[m[32m            status = limit.status[m
[32m+[m[32m            if status == AlertLevel.EMERGENCY:[m
[32m+[m[32m                breaches.append({[m
[32m+[m[32m                    "category": category.value,[m
[32m+[m[32m                    "value": limit.current_value,[m
[32m+[m[32m                    "limit": limit.emergency_limit,[m
[32m+[m[32m                    "action": "EMERGENCY LIQUIDATION REQUIRED"[m
[32m+[m[32m                })[m
[32m+[m[32m            elif status == AlertLevel.CRITICAL:[m
[32m+[m[32m                breaches.append({[m
[32m+[m[32m                    "category": category.value,[m
[32m+[m[32m                    "value": limit.current_value,[m
[32m+[m[32m                    "limit": limit.hard_limit,[m
[32m+[m[32m                    "action": "TRADING BLOCKED"[m
[32m+[m[32m                })[m
[32m+[m[32m            elif status == AlertLevel.WARNING:[m
[32m+[m[32m                warnings.append({[m
[32m+[m[32m                    "category": category.value,[m
[32m+[m[32m                    "value": limit.current_value,[m
[32m+[m[32m                    "limit": limit.soft_limit,[m
[32m+[m[32m                    "action": "SIZE REDUCTION"[m
[32m+[m[32m                })[m
[32m+[m[41m        [m
[32m+[m[32m        # Determine overall status[m
[32m+[m[32m        if any(b["action"] == "EMERGENCY LIQUIDATION REQUIRED" for b in breaches):[m
[32m+[m[32m            overall_status = "EMERGENCY"[m
[32m+[m[32m        elif breaches:[m
[32m+[m[32m            overall_status = "CRITICAL"[m
[32m+[m[32m        elif warnings:[m
[32m+[m[32m            overall_status = "WARNING"[m
[32m+[m[32m        else:[m
[32m+[m[32m            overall_status = "NORMAL"[m
[32m+[m[41m        [m
[32m+[m[32m        return {[m
[32m+[m[32m            "status": overall_status,[m
[32m+[m[32m            "portfolio": {[m
[32m+[m[32m                "equity": self.portfolio.total_equity,[m
[32m+[m[32m                "daily_pnl": self.portfolio.daily_pnl,[m
[32m+[m[32m                "daily_pnl_pct": self.portfolio.daily_pnl_pct,[m
[32m+[m[32m                "drawdown": self.portfolio.current_drawdown,[m
[32m+[m[32m                "gross_exposure": self.portfolio.gross_exposure / self.portfolio.total_equity,[m
[32m+[m[32m                "heat_level": self.portfolio.heat_level,[m
[32m+[m[32m            },[m
[32m+[m[32m            "breaches": breaches,[m
[32m+[m[32m            "warnings": warnings,[m
[32m+[m[32m            "limits": {k.value: v.to_dict() for k, v in self.limits.items()},[m
[32m+[m[32m            "trading_halted": self.trading_halted,[m
[32m+[m[32m            "human_intervention_required": self.human_intervention_required,[m
[32m+[m[32m            "timestamp": datetime.now().isoformat(),[m
[32m+[m[32m        }[m
[32m+[m[41m    [m
[32m+[m[32m    def _halt_trading(self, reason: str):[m
[32m+[m[32m        """Halt all trading."""[m
[32m+[m[32m        self.trading_halted = True[m
[32m+[m[32m        self.halt_reason = reason[m
[32m+[m[32m        self._issue_alert(AlertLevel.CRITICAL, f"TRADING HALTED: {reason}")[m
[32m+[m[32m        logger.critical(f"ðŸ›‘ðŸ›‘ðŸ›‘ KILLJOY HALTED TRADING: {reason}")[m
[32m+[m[41m    [m
[32m+[m[32m    def _emergency_liquidate(self, reason: str):[m
[32m+[m[32m        """NUCLEAR OPTION - Liquidate all positions."""[m
[32m+[m[32m        self.emergency_liquidations += 1[m
[32m+[m[32m        self.trading_halted = True[m
[32m+[m[32m        self.halt_reason = f"EMERGENCY LIQUIDATION: {reason}"[m
[32m+[m[32m        self.human_intervention_required = True[m
[32m+[m[32m        self._issue_alert(AlertLevel.APOCALYPSE, f"EMERGENCY LIQUIDATION: {reason}")[m
[32m+[m[32m        logger.critical(f"ðŸ’¥ðŸ’¥ðŸ’¥ KILLJOY EMERGENCY LIQUIDATION: {reason}")[m
[32m+[m[41m        [m
[32m+[m[32m        # In production, this would actually liquidate positions[m
[32m+[m[32m        # For now, just flag and alert[m
[32m+[m[41m    [m
[32m+[m[32m    def _issue_alert(self, level: AlertLevel, message: str):[m
[32m+[m[32m        """Issue an alert."""[m
[32m+[m[32m        alert = {[m
[32m+[m[32m            "level": level.value,[m
[32m+[m[32m            "message": message,[m
[32m+[m[32m            "timestamp": datetime.now().isoformat(),[m
[32m+[m[32m        }[m
[32m+[m[32m        self.alerts_issued.append(alert)[m
[32m+[m[41m        [m
[32m+[m[32m        # Escalate to HOAGS for critical alerts[m
[32m+[m[32m        if level in [AlertLevel.CRITICAL, AlertLevel.EMERGENCY, AlertLevel.APOCALYPSE]:[m
[32m+[m[32m            self._escalate_to_hoags(alert)[m
[32m+[m[41m    [m
[32m+[m[32m    def _escalate_to_hoags(self, alert: Dict):[m
[32m+[m[32m        """Escalate to HOAGS."""[m
[32m+[m[32m        logger.critical(f"ðŸ“¢ KILLJOY â†’ HOAGS: {alert['message']}")[m
[32m+[m[41m    [m
[32m+[m[32m    def update_portfolio([m
[32m+[m[32m        self,[m
[32m+[m[32m        equity: float = None,[m
[32m+[m[32m        daily_pnl: float = None,[m
[32m+[m[32m        positions: Dict = None,[m
[32m+[m[32m        trade_result: Dict = None[m
[32m+[m[32m    ):[m
[32m+[m[32m        """Update portfolio state."""[m
[32m+[m[32m        if equity is not None:[m
[32m+[m[32m            old_equity = self.portfolio.total_equity[m
[32m+[m[32m            self.portfolio.total_equity = equity[m
[32m+[m[41m            [m
[32m+[m[32m            # Update peak and drawdown[m
[32m+[m[32m            if equity > self.portfolio.peak_equity:[m
[32m+[m[32m                self.portfolio.peak_equity = equity[m
[32m+[m[41m            [m
[32m+[m[32m            self.portfolio.current_drawdown = (self.portfolio.peak_equity - equity) / self.portfolio.peak_equity[m
[32m+[m[32m            self.portfolio.max_drawdown = max(self.portfolio.max_drawdown, self.portfolio.current_drawdown)[m
[32m+[m[41m        [m
[32m+[m[32m        if daily_pnl is not None:[m
[32m+[m[32m            self.portfolio.daily_pnl = daily_pnl[m
[32m+[m[32m            self.portfolio.daily_pnl_pct = daily_pnl / self.portfolio.total_equity[m
[32m+[m[41m        [m
[32m+[m[32m        if positions is not None:[m
[32m+[m[32m            self.portfolio.positions = positions[m
[32m+[m[41m            [m
[32m+[m[32m            # Calculate exposures[m
[32m+[m[32m            long_val = sum(p.get("value", 0) for p in positions.values() if p.get("side") == "long")[m
[32m+[m[32m            short_val = sum(abs(p.get("value", 0)) for p in positions.values() if p.get("side") == "short")[m
[32m+[m[41m            [m
[32m+[m[32m            self.portfolio.long_exposure = long_val / self.portfolio.total_equity[m
[32m+[m[32m            self.portfolio.short_exposure = short_val / self.portfolio.total_equity[m
[32m+[m[32m            self.portfolio.gross_exposure = long_val + short_val[m
[32m+[m[32m            self.portfolio.net_exposure = long_val - short_val[m
[32m+[m[41m        [m
[32m+[m[32m        if trade_result is not None:[m
[32m+[m[32m            # Update heat based on trade result[m
[32m+[m[32m            if trade_result.get("pnl", 0) < 0:[m
[32m+[m[32m                self.portfolio.consecutive_losses += 1[m
[32m+[m[32m                self.portfolio.heat_level = min(100, self.portfolio.heat_level + 10)[m
[32m+[m[32m            else:[m
[32m+[m[32m                self.portfolio.consecutive_losses = 0[m
[32m+[m[32m                self.portfolio.heat_level = max(0, self.portfolio.heat_level - 5)[m
[32m+[m[41m    [m
[32m+[m[32m    def log_action(self, action: str, description: str):[m
[32m+[m[32m        """Log an action."""[m
[32m+[m[32m        self.logger.info(f"[KILLJOY] {action}: {description}")[m
[32m+[m[41m    [m
[32m+[m[32m    # =========================================================================[m
[32m+[m[32m    # TASK HANDLERS[m
[32m+[m[32m    # =========================================================================[m
[32m+[m[41m    [m
[32m+[m[32m    def _handle_approve_trade(self, params: Dict) -> Dict:[m
[32m+[m[32m        """Handle trade approval request."""[m
[32m+[m[32m        request = TradeRequest([m
[32m+[m[32m            request_id=params.get("request_id", f"req_{datetime.now().timestamp()}"),[m
[32m+[m[32m            agent_id=params.get("agent_id", "unknown"),[m
[32m+[m[32m            agent_name=params.get("agent_name", "Unknown"),[m
[32m+[m[32m            symbol=params.get("symbol", ""),[m
[32m+[m[32m            action=params.get("action", "BUY"),[m
[32m+[m[32m            quantity=params.get("quantity", 0),[m
[32m+[m[32m            price=params.get("price", 0),[m
[32m+[m[32m            order_type=params.get("order_type", "MARKET"),[m
[32m+[m[32m            confidence=params.get("confidence", 0.5),[m
[32m+[m[32m            reasoning=params.get("reasoning", ""),[m
[32m+[m[32m        )[m
[32m+[m[41m        [m
[32m+[m[32m        verdict = self.approve_trade(request)[m
[32m+[m[41m        [m
[32m+[m[32m        return {[m
[32m+[m[32m            "status": "approved" if verdict.approved else "blocked",[m
[32m+[m[32m            "verdict": verdict.to_dict(),[m
[32m+[m[32m        }[m
[32m+[m[41m    [m
[32m+[m[32m    def _handle_check_risk(self, params: Dict) -> Dict:[m
[32m+[m[32m        """Handle risk check request."""[m
[32m+[m[32m        return self.check_portfolio_risk()[m
[32m+[m[41m    [m
[32m+[m[32m    def _handle_update_portfolio(self, params: Dict) -> Dict:[m
[32m+[m[32m        """Handle portfolio update."""[m
[32m+[m[32m        self.update_portfolio([m
[32m+[m[32m            equity=params.get("equity"),[m
[32m+[m[32m            daily_pnl=params.get("daily_pnl"),[m
[32m+[m[32m            positions=params.get("positions"),[m
[32m+[m[32m            trade_result=params.get("trade_result"),[m
[32m+[m[32m        )[m
[32m+[m[32m        return {"status": "success", "portfolio": self.check_portfolio_risk()["portfolio"]}[m
[32m+[m[41m    [m
[32m+[m[32m    def _handle_get_limits(self, params: Dict) -> Dict:[m
[32m+[m[32m        """Get all risk limits."""[m
[32m+[m[32m        return {[m
[32m+[m[32m            "status": "success",[m
[32m+[m[32m            "limits": {k.value: v.to_dict() for k, v in self.limits.items()},[m
[32m+[m[32m        }[m
[32m+[m[41m    [m
[32m+[m[32m    def _handle_get_status(self, params: Dict) -> Dict:[m
[32m+[m[32m        """Get KILLJOY status."""[m
[32m+[m[32m        return {[m
[32m+[m[32m            "status": "success",[m
[32m+[m[32m            "killjoy": {[m
[32m+[m[32m                "trades_reviewed": self.trades_reviewed,[m
[32m+[m[32m                "trades_approved": self.trades_approved,[m
[32m+[m[32m                "trades_blocked": self.trades_blocked,[m
[32m+[m[32m                "trades_reduced": self.trades_reduced,[m
[32m+[m[32m                "emergency_liquidations": self.emergency_liquidations,[m
[32m+[m[32m                "trading_halted": self.trading_halted,[m
[32m+[m[32m                "halt_reason": self.halt_reason,[m
[32m+[m[32m                "human_intervention_required": self.human_intervention_required,[m
[32m+[m[32m                "recent_alerts": self.alerts_issued[-10:],[m
[32m+[m[32m            },[m
[32m+[m[32m            "risk": self.check_portfolio_risk(),[m
[32m+[m[32m        }[m
[32m+[m[41m    [m
[32m+[m[32m    def _handle_emergency_stop(self, params: Dict) -> Dict:[m
[32m+[m[32m        """Emergency stop all trading."""[m
[32m+[m[32m        reason = params.get("reason", "Manual emergency stop")[m
[32m+[m[32m        self._emergency_liquidate(reason)[m
[32m+[m[32m        return {"status": "success", "action": "EMERGENCY STOP ACTIVATED"}[m
[32m+[m[41m    [m
[32m+[m[32m    def _handle_reset_daily(self, params: Dict) -> Dict:[m
[32m+[m[32m        """Reset daily counters (run at market open)."""[m
[32m+[m[32m        self.portfolio.daily_pnl = 0[m
[32m+[m[32m        self.portfolio.daily_pnl_pct = 0[m
[32m+[m[41m        [m
[32m+[m[32m        if not self.human_intervention_required:[m
[32m+[m[32m            self.trading_halted = False[m
[32m+[m[32m            self.halt_reason = ""[m
[32m+[m[41m        [m
[32m+[m[32m        for limit in self.limits.values():[m
[32m+[m[32m            limit.breaches_today = 0[m
[32m+[m[41m        [m
[32m+[m[32m        return {"status": "success", "action": "DAILY RESET COMPLETE"}[m
[32m+[m[41m    [m
[32m+[m[32m    def _handle_override(self, params: Dict) -> Dict:[m
[32m+[m[32m        """Handle override request (TOM HOGAN ONLY)."""[m
[32m+[m[32m        override_code = params.get("override_code")[m
[32m+[m[41m        [m
[32m+[m[32m        # In production, this would verify Tom's authentication[m
[32m+[m[32m        if override_code != "TJH_OVERRIDE_2024":[m
[32m+[m[32m            logger.warning(f"ðŸš¨ UNAUTHORIZED OVERRIDE ATTEMPT")[m
[32m+[m[32m            return {"status": "error", "message": "UNAUTHORIZED"}[m
[32m+[m[41m        [m
[32m+[m[32m        action = params.get("action")[m
[32m+[m[41m        [m
[32m+[m[32m        if action == "resume_trading":[m
[32m+[m[32m            self.trading_halted = False[m
[32m+[m[32m            self.halt_reason = ""[m
[32m+[m[32m            self.human_intervention_required = False[m
[32m+[m[32m            logger.info("âœ… KILLJOY: Tom Hogan override - Trading resumed")[m
[32m+[m[32m            return {"status": "success", "action": "TRADING RESUMED"}[m
[32m+[m[41m        [m
[32m+[m[32m        return {"status": "error", "message": "Unknown override action"}[m
[32m+[m[41m    [m
[32m+[m[32m    def _handle_unknown(self, params: Dict) -> Dict:[m
[32m+[m[32m        return {"status": "error", "message": "Unknown action"}[m
[32m+[m
[32m+[m
[32m+[m[32m# =============================================================================[m
[32m+[m[32m# SINGLETON[m
[32m+[m[32m# =============================================================================[m
[32m+[m
[32m+[m[32m_killjoy_instance: Optional[KilljoyAgent] = None[m
[32m+[m
[32m+[m
[32m+[m[32mdef get_killjoy() -> KilljoyAgent:[m
[32m+[m[32m    """Get KILLJOY agent singleton."""[m
[32m+[m[32m    global _killjoy_instance[m
[32m+[m[32m    if _killjoy_instance is None:[m
[32m+[m[32m        _killjoy_instance = KilljoyAgent()[m
[32m+[m[32m    return _killjoy_instance[m
[32m+[m
[32m+[m
[32m+[m
[1mdiff --git a/dfu/src/core/institutional_grading.py b/dfu/src/core/institutional_grading.py[m
[1mnew file mode 100644[m
[1mindex 00000000..5eb5dd9d[m
[1m--- /dev/null[m
[1m+++ b/dfu/src/core/institutional_grading.py[m
[36m@@ -0,0 +1,881 @@[m
[32m+[m[32m"""[m
[32m+[m[32m================================================================================[m
[32m+[m[32mINSTITUTIONAL GRADING SYSTEM - CITADEL/GOLDMAN COMPETITION LEVEL[m
[32m+[m[32m================================================================================[m
[32m+[m[32mAuthor: Tom Hogan | Alpha Loop Capital, LLC[m
[32m+[m[32mVersion: 3.0 | December 2024[m
[32m+[m
[32m+[m[32mThis is NOT a participation trophy system. This is RUTHLESS grading designed[m
[32m+[m[32mto compete with the world's best hedge funds.[m
[32m+[m
[32m+[m[32mPhilosophy:[m
[32m+[m[32m- If it can't beat random by a SIGNIFICANT margin, TERMINATE IT[m
[32m+[m[32m- If it can't survive stress, TERMINATE IT[m[41m  [m
[32m+[m[32m- If it doesn't learn, TERMINATE IT[m
[32m+[m[32m- If it has EGO (overconfidence), TERMINATE IT[m
[32m+[m[32m- Only the ELITE survive[m
[32m+[m
[32m+[m[32mGrade Scale:[m
[32m+[m[32m- S+ : Citadel Elite (top 0.1% of all agents ever created)[m
[32m+[m[32m- S  : Goldman/Renaissance level (top 1%)[m
[32m+[m[32m- A+ : Institutional grade - PROMOTED TO LIVE[m
[32m+[m[32m- A  : Institutional grade - PROMOTED TO PAPER[m
[32m+[m[32m- B+ : Promising - Continue training with priority[m
[32m+[m[32m- B  : Acceptable - Continue training[m
[32m+[m[32m- C  : Below standard - PROBATION (24hr to improve or terminate)[m
[32m+[m[32m- D  : Unacceptable - IMMEDIATE TERMINATION[m
[32m+[m[32m- F  : Dangerous - BLACKLIST (never recreate this configuration)[m
[32m+[m
[32m+[m[32m"By end of 2026, they will know Alpha Loop Capital."[m
[32m+[m[32m================================================================================[m
[32m+[m[32m"""[m
[32m+[m
[32m+[m[32mfrom dataclasses import dataclass, field[m
[32m+[m[32mfrom typing import Dict, Any, List, Tuple, Optional[m
[32m+[m[32mfrom enum import Enum[m
[32m+[m[32mfrom datetime import datetime, timedelta[m
[32m+[m[32mimport math[m
[32m+[m
[32m+[m
[32m+[m[32mclass GradeLevel(Enum):[m
[32m+[m[32m    """Institutional grade levels."""[m
[32m+[m[32m    S_PLUS = "S+"    # Citadel Elite[m
[32m+[m[32m    S = "S"          # Goldman/Renaissance[m
[32m+[m[32m    A_PLUS = "A+"    # Institutional - Live[m
[32m+[m[32m    A = "A"          # Institutional - Paper[m
[32m+[m[32m    B_PLUS = "B+"    # Promising[m
[32m+[m[32m    B = "B"          # Acceptable[m
[32m+[m[32m    C = "C"          # Probation[m
[32m+[m[32m    D = "D"          # Terminate[m
[32m+[m[32m    F = "F"          # Blacklist[m
[32m+[m
[32m+[m
[32m+[m[32mclass AgentCategory(Enum):[m
[32m+[m[32m    """Agent categories with different standards."""[m
[32m+[m[32m    MASTER = "master"          # HOAGS, GHOST[m
[32m+[m[32m    SENIOR = "senior"          # SCOUT, HUNTER, BOOKMAKER, etc.[m
[32m+[m[32m    OPERATIONAL = "operational" # Data, Execution, Risk, etc.[m
[32m+[m[32m    STRATEGY = "strategy"      # 34 strategy agents[m
[32m+[m[32m    SECTOR = "sector"          # 11 sector agents[m
[32m+[m[32m    SWARM = "swarm"           # Dynamically created[m
[32m+[m
[32m+[m
[32m+[m[32m@dataclass(frozen=True)[m
[32m+[m[32mclass InstitutionalThresholds:[m
[32m+[m[32m    """[m
[32m+[m[32m    RUTHLESS thresholds for institutional-grade trading.[m
[32m+[m[41m    [m
[32m+[m[32m    These are based on what Citadel, Renaissance, Goldman actually require.[m
[32m+[m[32m    If you can't meet these, you don't belong in production.[m
[32m+[m[32m    """[m
[32m+[m[41m    [m
[32m+[m[32m    # =========================================================================[m
[32m+[m[32m    # PREDICTION QUALITY (The Core)[m
[32m+[m[32m    # =========================================================================[m
[32m+[m[41m    [m
[32m+[m[32m    # AUC (Area Under Curve) - Most Important Metric[m
[32m+[m[32m    min_auc_live: float = 0.58          # Must beat random by 16%+ for live[m
[32m+[m[32m    min_auc_paper: float = 0.55         # Must beat random by 10%+ for paper[m
[32m+[m[32m    min_auc_training: float = 0.52      # Must beat random by 4%+ to continue[m
[32m+[m[32m    max_auc_suspicious: float = 0.70    # Above this = likely overfitting[m
[32m+[m[41m    [m
[32m+[m[32m    # Accuracy[m
[32m+[m[32m    min_accuracy_live: float = 0.56     # 56%+ for live trading[m
[32m+[m[32m    min_accuracy_paper: float = 0.54    # 54%+ for paper trading[m
[32m+[m[32m    min_accuracy_training: float = 0.52 # 52%+ to continue training[m
[32m+[m[41m    [m
[32m+[m[32m    # Precision (When we say BUY, we better be right)[m
[32m+[m[32m    min_precision: float = 0.55         # 55%+ precision on signals[m
[32m+[m[41m    [m
[32m+[m[32m    # =========================================================================[m
[32m+[m[32m    # RISK METRICS (The Guardrails)[m
[32m+[m[32m    # =========================================================================[m
[32m+[m[41m    [m
[32m+[m[32m    # Sharpe Ratio (Risk-Adjusted Returns)[m
[32m+[m[32m    min_sharpe_live: float = 2.0        # Sharpe 2.0+ for live (top 5% hedge funds)[m
[32m+[m[32m    min_sharpe_paper: float = 1.5       # Sharpe 1.5+ for paper[m
[32m+[m[32m    min_sharpe_training: float = 1.0    # Sharpe 1.0+ to continue[m
[32m+[m[41m    [m
[32m+[m[32m    # Sortino Ratio (Downside Risk)[m
[32m+[m[32m    min_sortino: float = 2.5            # Must have asymmetric returns[m
[32m+[m[41m    [m
[32m+[m[32m    # Calmar Ratio (Return/Max Drawdown)[m
[32m+[m[32m    min_calmar: float = 1.5             # Return must exceed drawdown[m
[32m+[m[41m    [m
[32m+[m[32m    # Maximum Drawdown[m
[32m+[m[32m    max_drawdown_live: float = 0.05     # 5% max drawdown for live[m
[32m+[m[32m    max_drawdown_paper: float = 0.08    # 8% max drawdown for paper[m
[32m+[m[32m    max_drawdown_training: float = 0.12 # 12% max during training[m
[32m+[m[41m    [m
[32m+[m[32m    # Value at Risk (95th percentile)[m
[32m+[m[32m    max_var_95: float = 0.02            # 2% VaR limit[m
[32m+[m[41m    [m
[32m+[m[32m    # =========================================================================[m
[32m+[m[32m    # TRADING METRICS (The Execution)[m
[32m+[m[32m    # =========================================================================[m
[32m+[m[41m    [m
[32m+[m[32m    # Win Rate[m
[32m+[m[32m    min_win_rate: float = 0.52          # Must win more than lose[m
[32m+[m[41m    [m
[32m+[m[32m    # Profit Factor (Gross Profits / Gross Losses)[m
[32m+[m[32m    min_profit_factor: float = 1.5      # Must make 50% more than you lose[m
[32m+[m[41m    [m
[32m+[m[32m    # Average Win / Average Loss[m
[32m+[m[32m    min_win_loss_ratio: float = 1.2     # Avg win must exceed avg loss by 20%[m
[32m+[m[41m    [m
[32m+[m[32m    # Trade Count (Proof of concept)[m
[32m+[m[32m    min_trades_live: int = 500          # 500+ trades proven for live[m
[32m+[m[32m    min_trades_paper: int = 200         # 200+ trades for paper[m
[32m+[m[32m    min_trades_training: int = 50       # 50+ trades to evaluate[m
[32m+[m[41m    [m
[32m+[m[32m    # =========================================================================[m
[32m+[m[32m    # EXPERIENCE METRICS (The Battle Scars)[m
[32m+[m[32m    # =========================================================================[m
[32m+[m[41m    [m
[32m+[m[32m    # Execution Count[m
[32m+[m[32m    min_executions_live: int = 1000     # 1000+ successful executions[m
[32m+[m[32m    min_executions_paper: int = 500     # 500+ for paper[m
[32m+[m[32m    min_executions_training: int = 100  # 100+ for continued training[m
[32m+[m[41m    [m
[32m+[m[32m    # Learning Events[m
[32m+[m[32m    min_learning_events: int = 1000     # Must have learned from 1000+ outcomes[m
[32m+[m[41m    [m
[32m+[m[32m    # Battle Stats (Stress Survival)[m
[32m+[m[32m    min_crashes_survived: int = 5       # Must survive 5+ system crashes[m
[32m+[m[32m    min_drawdowns_navigated: int = 10   # Must navigate 10+ drawdown periods[m
[32m+[m[32m    min_regime_changes: int = 3         # Must adapt to 3+ regime changes[m
[32m+[m[32m    min_black_swans: int = 1            # Must survive at least 1 black swan[m
[32m+[m[41m    [m
[32m+[m[32m    # =========================================================================[m
[32m+[m[32m    # CAPABILITY METRICS (The Skillset)[m
[32m+[m[32m    # =========================================================================[m
[32m+[m[41m    [m
[32m+[m[32m    # Capabilities[m
[32m+[m[32m    min_capabilities_master: int = 15   # Masters need 15+ capabilities[m
[32m+[m[32m    min_capabilities_senior: int = 10   # Seniors need 10+[m
[32m+[m[32m    min_capabilities_standard: int = 5  # Standard need 5+[m
[32m+[m[41m    [m
[32m+[m[32m    # =========================================================================[m
[32m+[m[32m    # CALIBRATION METRICS (The Humility)[m
[32m+[m[32m    # =========================================================================[m
[32m+[m[41m    [m
[32m+[m[32m    # Confidence Calibration (Agents that are overconfident get penalized)[m
[32m+[m[32m    max_overconfidence: float = 0.10    # Can't be >10% overconfident[m
[32m+[m[32m    min_confidence_calibration: float = 0.85  # Must be 85%+ calibrated[m
[32m+[m[41m    [m
[32m+[m[32m    # =========================================================================[m
[32m+[m[32m    # CONSISTENCY METRICS (The Reliability)[m
[32m+[m[32m    # =========================================================================[m
[32m+[m[41m    [m
[32m+[m[32m    # Cross-Validation Consistency[m
[32m+[m[32m    max_cv_std: float = 0.05            # CV scores can't vary more than 5%[m
[32m+[m[41m    [m
[32m+[m[32m    # Out-of-Sample Degradation[m
[32m+[m[32m    max_oos_degradation: float = 0.10   # OOS can't be >10% worse than training[m
[32m+[m[41m    [m
[32m+[m[32m    # Rolling Window Stability[m
[32m+[m[32m    min_rolling_consistency: float = 0.80  # 80%+ consistent across time windows[m
[32m+[m
[32m+[m
[32m+[m[32m@dataclass[m
[32m+[m[32mclass AgentGradeReport:[m
[32m+[m[32m    """Comprehensive grade report for an agent."""[m
[32m+[m[32m    agent_id: str[m
[32m+[m[32m    agent_name: str[m
[32m+[m[32m    category: AgentCategory[m
[32m+[m[41m    [m
[32m+[m[32m    # Final Grade[m
[32m+[m[32m    grade: GradeLevel[m
[32m+[m[32m    grade_score: float  # 0-100 numerical score[m
[32m+[m[41m    [m
[32m+[m[32m    # Verdict[m
[32m+[m[32m    promoted: bool[m
[32m+[m[32m    promotion_level: str  # "LIVE", "PAPER", "TRAINING", "TERMINATED", "BLACKLISTED"[m
[32m+[m[41m    [m
[32m+[m[32m    # Metric Scores (each 0-100)[m
[32m+[m[32m    prediction_score: float[m
[32m+[m[32m    risk_score: float[m
[32m+[m[32m    trading_score: float[m
[32m+[m[32m    experience_score: float[m
[32m+[m[32m    capability_score: float[m
[32m+[m[32m    calibration_score: float[m
[32m+[m[32m    consistency_score: float[m
[32m+[m[41m    [m
[32m+[m[32m    # Detailed Metrics[m
[32m+[m[32m    metrics: Dict[str, Any][m
[32m+[m[41m    [m
[32m+[m[32m    # Issues Found[m
[32m+[m[32m    critical_failures: List[str][m
[32m+[m[32m    warnings: List[str][m
[32m+[m[32m    strengths: List[str][m
[32m+[m[41m    [m
[32m+[m[32m    # Recommendations[m
[32m+[m[32m    action_required: str[m
[32m+[m[32m    improvement_areas: List[str][m
[32m+[m[41m    [m
[32m+[m[32m    # Metadata[m
[32m+[m[32m    graded_at: datetime = field(default_factory=datetime.now)[m
[32m+[m[32m    graded_by: str = "InstitutionalGrader"[m
[32m+[m[41m    [m
[32m+[m[32m    def to_dict(self) -> Dict[str, Any]:[m
[32m+[m[32m        return {[m
[32m+[m[32m            "agent_id": self.agent_id,[m
[32m+[m[32m            "agent_name": self.agent_name,[m
[32m+[m[32m            "category": self.category.value,[m
[32m+[m[32m            "grade": self.grade.value,[m
[32m+[m[32m            "grade_score": self.grade_score,[m
[32m+[m[32m            "promoted": self.promoted,[m
[32m+[m[32m            "promotion_level": self.promotion_level,[m
[32m+[m[32m            "scores": {[m
[32m+[m[32m                "prediction": self.prediction_score,[m
[32m+[m[32m                "risk": self.risk_score,[m
[32m+[m[32m                "trading": self.trading_score,[m
[32m+[m[32m                "experience": self.experience_score,[m
[32m+[m[32m                "capability": self.capability_score,[m
[32m+[m[32m                "calibration": self.calibration_score,[m
[32m+[m[32m                "consistency": self.consistency_score,[m
[32m+[m[32m            },[m
[32m+[m[32m            "critical_failures": self.critical_failures,[m
[32m+[m[32m            "warnings": self.warnings,[m
[32m+[m[32m            "strengths": self.strengths,[m
[32m+[m[32m            "action_required": self.action_required,[m
[32m+[m[32m            "graded_at": self.graded_at.isoformat(),[m
[32m+[m[32m        }[m
[32m+[m
[32m+[m
[32m+[m[32mclass InstitutionalGrader:[m
[32m+[m[32m    """[m
[32m+[m[32m    RUTHLESS institutional-grade agent grader.[m
[32m+[m[41m    [m
[32m+[m[32m    This grader has ONE job: ensure only ELITE agents make it to production.[m
[32m+[m[41m    [m
[32m+[m[32m    It evaluates 7 dimensions:[m
[32m+[m[32m    1. Prediction Quality (AUC, Accuracy, Precision)[m
[32m+[m[32m    2. Risk Management (Sharpe, Sortino, Drawdown, VaR)[m
[32m+[m[32m    3. Trading Performance (Win Rate, Profit Factor)[m
[32m+[m[32m    4. Battle Experience (Crashes, Drawdowns, Black Swans)[m
[32m+[m[32m    5. Capabilities (Skills, Methods)[m
[32m+[m[32m    6. Calibration (Confidence accuracy)[m
[32m+[m[32m    7. Consistency (Stability over time)[m
[32m+[m[41m    [m
[32m+[m[32m    Grading Philosophy:[m
[32m+[m[32m    - One critical failure = IMMEDIATE TERMINATION[m
[32m+[m[32m    - Multiple warnings = PROBATION[m
[32m+[m[32m    - Mediocrity is not tolerated[m
[32m+[m[32m    - Only the best survive[m
[32m+[m[32m    """[m
[32m+[m[41m    [m
[32m+[m[32m    def __init__(self, thresholds: InstitutionalThresholds = None):[m
[32m+[m[32m        self.thresholds = thresholds or InstitutionalThresholds()[m
[32m+[m[32m        self.grading_history: List[AgentGradeReport] = [][m
[32m+[m[41m        [m
[32m+[m[32m        # Weight multipliers for final score[m
[32m+[m[32m        self.weights = {[m
[32m+[m[32m            "prediction": 0.25,    # 25% - Core value[m
[32m+[m[32m            "risk": 0.25,          # 25% - Critical for survival[m
[32m+[m[32m            "trading": 0.20,       # 20% - Execution matters[m
[32m+[m[32m            "experience": 0.10,    # 10% - Battle-tested[m
[32m+[m[32m            "capability": 0.08,    # 8% - Skillset[m
[32m+[m[32m            "calibration": 0.07,   # 7% - Humility[m
[32m+[m[32m            "consistency": 0.05,   # 5% - Reliability[m
[32m+[m[32m        }[m
[32m+[m[41m    [m
[32m+[m[32m    def grade_agent([m
[32m+[m[32m        self,[m
[32m+[m[32m        agent_id: str,[m
[32m+[m[32m        agent_name: str,[m
[32m+[m[32m        category: AgentCategory,[m
[32m+[m[32m        stats: Dict[str, Any][m
[32m+[m[32m    ) -> AgentGradeReport:[m
[32m+[m[32m        """[m
[32m+[m[32m        Grade an agent against institutional standards.[m
[32m+[m[41m        [m
[32m+[m[32m        Args:[m
[32m+[m[32m            agent_id: Unique agent identifier[m
[32m+[m[32m            agent_name: Human-readable name[m
[32m+[m[32m            category: Agent category (affects standards)[m
[32m+[m[32m            stats: Dictionary of all agent statistics[m
[32m+[m[41m            [m
[32m+[m[32m        Returns:[m
[32m+[m[32m            Comprehensive AgentGradeReport[m
[32m+[m[32m        """[m
[32m+[m[32m        t = self.thresholds[m
[32m+[m[41m        [m
[32m+[m[32m        critical_failures = [][m
[32m+[m[32m        warnings = [][m
[32m+[m[32m        strengths = [][m
[32m+[m[41m        [m
[32m+[m[32m        # =====================================================================[m
[32m+[m[32m        # DIMENSION 1: PREDICTION QUALITY (25%)[m
[32m+[m[32m        # =====================================================================[m
[32m+[m[32m        prediction_score, pred_failures, pred_warnings, pred_strengths = \[m
[32m+[m[32m            self._grade_prediction(stats, t)[m
[32m+[m[32m        critical_failures.extend(pred_failures)[m
[32m+[m[32m        warnings.extend(pred_warnings)[m
[32m+[m[32m        strengths.extend(pred_strengths)[m
[32m+[m[41m        [m
[32m+[m[32m        # =====================================================================[m
[32m+[m[32m        # DIMENSION 2: RISK MANAGEMENT (25%)[m
[32m+[m[32m        # =====================================================================[m
[32m+[m[32m        risk_score, risk_failures, risk_warnings, risk_strengths = \[m
[32m+[m[32m            self._grade_risk(stats, t)[m
[32m+[m[32m        critical_failures.extend(risk_failures)[m
[32m+[m[32m        warnings.extend(risk_warnings)[m
[32m+[m[32m        strengths.extend(risk_strengths)[m
[32m+[m[41m        [m
[32m+[m[32m        # =====================================================================[m
[32m+[m[32m        # DIMENSION 3: TRADING PERFORMANCE (20%)[m
[32m+[m[32m        # =====================================================================[m
[32m+[m[32m        trading_score, trade_failures, trade_warnings, trade_strengths = \[m
[32m+[m[32m            self._grade_trading(stats, t)[m
[32m+[m[32m        critical_failures.extend(trade_failures)[m
[32m+[m[32m        warnings.extend(trade_warnings)[m
[32m+[m[32m        strengths.extend(trade_strengths)[m
[32m+[m[41m        [m
[32m+[m[32m        # =====================================================================[m
[32m+[m[32m        # DIMENSION 4: BATTLE EXPERIENCE (10%)[m
[32m+[m[32m        # =====================================================================[m
[32m+[m[32m        experience_score, exp_failures, exp_warnings, exp_strengths = \[m
[32m+[m[32m            self._grade_experience(stats, t)[m
[32m+[m[32m        critical_failures.extend(exp_failures)[m
[32m+[m[32m        warnings.extend(exp_warnings)[m
[32m+[m[32m        strengths.extend(exp_strengths)[m
[32m+[m[41m        [m
[32m+[m[32m        # =====================================================================[m
[32m+[m[32m        # DIMENSION 5: CAPABILITIES (8%)[m
[32m+[m[32m        # =====================================================================[m
[32m+[m[32m        capability_score, cap_failures, cap_warnings, cap_strengths = \[m
[32m+[m[32m            self._grade_capabilities(stats, t, category)[m
[32m+[m[32m        critical_failures.extend(cap_failures)[m
[32m+[m[32m        warnings.extend(cap_warnings)[m
[32m+[m[32m        strengths.extend(cap_strengths)[m
[32m+[m[41m        [m
[32m+[m[32m        # =====================================================================[m
[32m+[m[32m        # DIMENSION 6: CALIBRATION (7%)[m
[32m+[m[32m        # =====================================================================[m
[32m+[m[32m        calibration_score, cal_failures, cal_warnings, cal_strengths = \[m
[32m+[m[32m            self._grade_calibration(stats, t)[m
[32m+[m[32m        critical_failures.extend(cal_failures)[m
[32m+[m[32m        warnings.extend(cal_warnings)[m
[32m+[m[32m        strengths.extend(cal_strengths)[m
[32m+[m[41m        [m
[32m+[m[32m        # =====================================================================[m
[32m+[m[32m        # DIMENSION 7: CONSISTENCY (5%)[m
[32m+[m[32m        # =====================================================================[m
[32m+[m[32m        consistency_score, con_failures, con_warnings, con_strengths = \[m
[32m+[m[32m            self._grade_consistency(stats, t)[m
[32m+[m[32m        critical_failures.extend(con_failures)[m
[32m+[m[32m        warnings.extend(con_warnings)[m
[32m+[m[32m        strengths.extend(con_strengths)[m
[32m+[m[41m        [m
[32m+[m[32m        # =====================================================================[m
[32m+[m[32m        # CALCULATE FINAL SCORE[m
[32m+[m[32m        # =====================================================================[m
[32m+[m[32m        final_score = ([m
[32m+[m[32m            prediction_score * self.weights["prediction"] +[m
[32m+[m[32m            risk_score * self.weights["risk"] +[m
[32m+[m[32m            trading_score * self.weights["trading"] +[m
[32m+[m[32m            experience_score * self.weights["experience"] +[m
[32m+[m[32m            capability_score * self.weights["capability"] +[m
[32m+[m[32m            calibration_score * self.weights["calibration"] +[m
[32m+[m[32m            consistency_score * self.weights["consistency"][m
[32m+[m[32m        )[m
[32m+[m[41m        [m
[32m+[m[32m        # =====================================================================[m
[32m+[m[32m        # DETERMINE GRADE[m
[32m+[m[32m        # =====================================================================[m
[32m+[m[32m        grade, promoted, promotion_level, action = self._determine_grade([m
[32m+[m[32m            final_score, critical_failures, warnings, category[m
[32m+[m[32m        )[m
[32m+[m[41m        [m
[32m+[m[32m        # =====================================================================[m
[32m+[m[32m        # GENERATE IMPROVEMENT AREAS[m
[32m+[m[32m        # =====================================================================[m
[32m+[m[32m        improvement_areas = self._identify_improvements([m
[32m+[m[32m            prediction_score, risk_score, trading_score,[m[41m [m
[32m+[m[32m            experience_score, capability_score,[m[41m [m
[32m+[m[32m            calibration_score, consistency_score[m
[32m+[m[32m        )[m
[32m+[m[41m        [m
[32m+[m[32m        # =====================================================================[m
[32m+[m[32m        # CREATE REPORT[m
[32m+[m[32m        # =====================================================================[m
[32m+[m[32m        report = AgentGradeReport([m
[32m+[m[32m            agent_id=agent_id,[m
[32m+[m[32m            agent_name=agent_name,[m
[32m+[m[32m            category=category,[m
[32m+[m[32m            grade=grade,[m
[32m+[m[32m            grade_score=final_score,[m
[32m+[m[32m            promoted=promoted,[m
[32m+[m[32m            promotion_level=promotion_level,[m
[32m+[m[32m            prediction_score=prediction_score,[m
[32m+[m[32m            risk_score=risk_score,[m
[32m+[m[32m            trading_score=trading_score,[m
[32m+[m[32m            experience_score=experience_score,[m
[32m+[m[32m            capability_score=capability_score,[m
[32m+[m[32m            calibration_score=calibration_score,[m
[32m+[m[32m            consistency_score=consistency_score,[m
[32m+[m[32m            metrics=stats,[m
[32m+[m[32m            critical_failures=critical_failures,[m
[32m+[m[32m            warnings=warnings,[m
[32m+[m[32m            strengths=strengths,[m
[32m+[m[32m            action_required=action,[m
[32m+[m[32m            improvement_areas=improvement_areas,[m
[32m+[m[32m        )[m
[32m+[m[41m        [m
[32m+[m[32m        self.grading_history.append(report)[m
[32m+[m[41m        [m
[32m+[m[32m        return report[m
[32m+[m[41m    [m
[32m+[m[32m    def _grade_prediction([m
[32m+[m[32m        self, stats: Dict, t: InstitutionalThresholds[m
[32m+[m[32m    ) -> Tuple[float, List[str], List[str], List[str]]:[m
[32m+[m[32m        """Grade prediction quality."""[m
[32m+[m[32m        failures, warnings, strengths = [], [], [][m
[32m+[m[32m        scores = [][m
[32m+[m[41m        [m
[32m+[m[32m        # AUC[m
[32m+[m[32m        auc = stats.get("auc", 0.5)[m
[32m+[m[32m        if auc < t.min_auc_training:[m
[32m+[m[32m            failures.append(f"CRITICAL: AUC {auc:.3f} < {t.min_auc_training} (random)")[m
[32m+[m[32m        elif auc > t.max_auc_suspicious:[m
[32m+[m[32m            warnings.append(f"SUSPICIOUS: AUC {auc:.3f} > {t.max_auc_suspicious} (overfitting?)")[m
[32m+[m[32m        elif auc >= t.min_auc_live:[m
[32m+[m[32m            strengths.append(f"EXCELLENT AUC: {auc:.3f} (live-ready)")[m
[32m+[m[41m        [m
[32m+[m[32m        auc_score = min(100, max(0, (auc - 0.5) / (0.65 - 0.5) * 100))[m
[32m+[m[32m        scores.append(auc_score)[m
[32m+[m[41m        [m
[32m+[m[32m        # Accuracy[m
[32m+[m[32m        accuracy = stats.get("accuracy", 0.5)[m
[32m+[m[32m        if accuracy < t.min_accuracy_training:[m
[32m+[m[32m            failures.append(f"CRITICAL: Accuracy {accuracy:.1%} < {t.min_accuracy_training:.0%}")[m
[32m+[m[32m        elif accuracy >= t.min_accuracy_live:[m
[32m+[m[32m            strengths.append(f"EXCELLENT Accuracy: {accuracy:.1%}")[m
[32m+[m[41m        [m
[32m+[m[32m        acc_score = min(100, max(0, (accuracy - 0.5) / (0.60 - 0.5) * 100))[m
[32m+[m[32m        scores.append(acc_score)[m
[32m+[m[41m        [m
[32m+[m[32m        # Precision[m
[32m+[m[32m        precision = stats.get("precision", 0.5)[m
[32m+[m[32m        if precision < t.min_precision:[m
[32m+[m[32m            warnings.append(f"LOW Precision: {precision:.1%} < {t.min_precision:.0%}")[m
[32m+[m[32m        elif precision >= 0.60:[m
[32m+[m[32m            strengths.append(f"HIGH Precision: {precision:.1%}")[m
[32m+[m[41m        [m
[32m+[m[32m        prec_score = min(100, max(0, (precision - 0.5) / (0.65 - 0.5) * 100))[m
[32m+[m[32m        scores.append(prec_score)[m
[32m+[m[41m        [m
[32m+[m[32m        return sum(scores) / len(scores), failures, warnings, strengths[m
[32m+[m[41m    [m
[32m+[m[32m    def _grade_risk([m
[32m+[m[32m        self, stats: Dict, t: InstitutionalThresholds[m
[32m+[m[32m    ) -> Tuple[float, List[str], List[str], List[str]]:[m
[32m+[m[32m        """Grade risk management."""[m
[32m+[m[32m        failures, warnings, strengths = [], [], [][m
[32m+[m[32m        scores = [][m
[32m+[m[41m        [m
[32m+[m[32m        # Sharpe Ratio[m
[32m+[m[32m        sharpe = stats.get("sharpe_ratio", stats.get("sharpe", 0))[m
[32m+[m[32m        if sharpe < t.min_sharpe_training:[m
[32m+[m[32m            failures.append(f"CRITICAL: Sharpe {sharpe:.2f} < {t.min_sharpe_training}")[m
[32m+[m[32m        elif sharpe >= t.min_sharpe_live:[m
[32m+[m[32m            strengths.append(f"EXCELLENT Sharpe: {sharpe:.2f} (live-ready)")[m
[32m+[m[41m        [m
[32m+[m[32m        sharpe_score = min(100, max(0, sharpe / 2.5 * 100))[m
[32m+[m[32m        scores.append(sharpe_score)[m
[32m+[m[41m        [m
[32m+[m[32m        # Max Drawdown[m
[32m+[m[32m        drawdown = stats.get("max_drawdown", 1.0)[m
[32m+[m[32m        if drawdown > t.max_drawdown_training:[m
[32m+[m[32m            failures.append(f"CRITICAL: Drawdown {drawdown:.1%} > {t.max_drawdown_training:.0%}")[m
[32m+[m[32m        elif drawdown <= t.max_drawdown_live:[m
[32m+[m[32m            strengths.append(f"LOW Drawdown: {drawdown:.1%}")[m
[32m+[m[41m        [m
[32m+[m[32m        dd_score = min(100, max(0, (1 - drawdown / 0.20) * 100))[m
[32m+[m[32m        scores.append(dd_score)[m
[32m+[m[41m        [m
[32m+[m[32m        # Sortino Ratio[m
[32m+[m[32m        sortino = stats.get("sortino_ratio", stats.get("sortino", 0))[m
[32m+[m[32m        if sortino >= t.min_sortino:[m
[32m+[m[32m            strengths.append(f"EXCELLENT Sortino: {sortino:.2f}")[m
[32m+[m[41m        [m
[32m+[m[32m        sortino_score = min(100, max(0, sortino / 3.0 * 100))[m
[32m+[m[32m        scores.append(sortino_score)[m
[32m+[m[41m        [m
[32m+[m[32m        # VaR[m
[32m+[m[32m        var = stats.get("var_95", stats.get("var", 0.05))[m
[32m+[m[32m        if var > t.max_var_95:[m
[32m+[m[32m            warnings.append(f"HIGH VaR: {var:.1%} > {t.max_var_95:.0%}")[m
[32m+[m[41m        [m
[32m+[m[32m        var_score = min(100, max(0, (1 - var / 0.05) * 100))[m
[32m+[m[32m        scores.append(var_score)[m
[32m+[m[41m        [m
[32m+[m[32m        return sum(scores) / len(scores), failures, warnings, strengths[m
[32m+[m[41m    [m
[32m+[m[32m    def _grade_trading([m
[32m+[m[32m        self, stats: Dict, t: InstitutionalThresholds[m
[32m+[m[32m    ) -> Tuple[float, List[str], List[str], List[str]]:[m
[32m+[m[32m        """Grade trading performance."""[m
[32m+[m[32m        failures, warnings, strengths = [], [], [][m
[32m+[m[32m        scores = [][m
[32m+[m[41m        [m
[32m+[m[32m        # Win Rate[m
[32m+[m[32m        win_rate = stats.get("win_rate", 0.5)[m
[32m+[m[32m        if win_rate < t.min_win_rate:[m
[32m+[m[32m            warnings.append(f"LOW Win Rate: {win_rate:.1%} < {t.min_win_rate:.0%}")[m
[32m+[m[32m        elif win_rate >= 0.55:[m
[32m+[m[32m            strengths.append(f"HIGH Win Rate: {win_rate:.1%}")[m
[32m+[m[41m        [m
[32m+[m[32m        wr_score = min(100, max(0, (win_rate - 0.45) / (0.60 - 0.45) * 100))[m
[32m+[m[32m        scores.append(wr_score)[m
[32m+[m[41m        [m
[32m+[m[32m        # Profit Factor[m
[32m+[m[32m        pf = stats.get("profit_factor", 1.0)[m
[32m+[m[32m        if pf < t.min_profit_factor:[m
[32m+[m[32m            warnings.append(f"LOW Profit Factor: {pf:.2f} < {t.min_profit_factor}")[m
[32m+[m[32m        elif pf >= 2.0:[m
[32m+[m[32m            strengths.append(f"EXCELLENT Profit Factor: {pf:.2f}")[m
[32m+[m[41m        [m
[32m+[m[32m        pf_score = min(100, max(0, (pf - 1.0) / (2.5 - 1.0) * 100))[m
[32m+[m[32m        scores.append(pf_score)[m
[32m+[m[41m        [m
[32m+[m[32m        # Trade Count[m
[32m+[m[32m        trades = stats.get("total_trades", stats.get("execution_count", 0))[m
[32m+[m[32m        if trades < t.min_trades_training:[m
[32m+[m[32m            failures.append(f"INSUFFICIENT TRADES: {trades} < {t.min_trades_training}")[m
[32m+[m[32m        elif trades >= t.min_trades_live:[m
[32m+[m[32m            strengths.append(f"WELL-TESTED: {trades} trades")[m
[32m+[m[41m        [m
[32m+[m[32m        trade_score = min(100, max(0, trades / t.min_trades_live * 100))[m
[32m+[m[32m        scores.append(trade_score)[m
[32m+[m[41m        [m
[32m+[m[32m        return sum(scores) / len(scores), failures, warnings, strengths[m
[32m+[m[41m    [m
[32m+[m[32m    def _grade_experience([m
[32m+[m[32m        self, stats: Dict, t: InstitutionalThresholds[m
[32m+[m[32m    ) -> Tuple[float, List[str], List[str], List[str]]:[m
[32m+[m[32m        """Grade battle experience."""[m
[32m+[m[32m        failures, warnings, strengths = [], [], [][m
[32m+[m[32m        scores = [][m
[32m+[m[41m        [m
[32m+[m[32m        battle_stats = stats.get("battle_stats", {})[m
[32m+[m[41m        [m
[32m+[m[32m        # Crashes Survived[m
[32m+[m[32m        crashes = battle_stats.get("crashes_survived", 0)[m
[32m+[m[32m        if crashes >= t.min_crashes_survived:[m
[32m+[m[32m            strengths.append(f"RESILIENT: Survived {crashes} crashes")[m
[32m+[m[32m        else:[m
[32m+[m[32m            warnings.append(f"UNTESTED: Only {crashes} crashes (need {t.min_crashes_survived})")[m
[32m+[m[32m        crash_score = min(100, crashes / t.min_crashes_survived * 100)[m
[32m+[m[32m        scores.append(crash_score)[m
[32m+[m[41m        [m
[32m+[m[32m        # Drawdowns Navigated[m
[32m+[m[32m        drawdowns = battle_stats.get("drawdowns_navigated", 0)[m
[32m+[m[32m        if drawdowns >= t.min_drawdowns_navigated:[m
[32m+[m[32m            strengths.append(f"BATTLE-HARDENED: Navigated {drawdowns} drawdowns")[m
[32m+[m[32m        else:[m
[32m+[m[32m            warnings.append(f"INEXPERIENCED: Only {drawdowns} drawdowns")[m
[32m+[m[32m        dd_score = min(100, drawdowns / t.min_drawdowns_navigated * 100)[m
[32m+[m[32m        scores.append(dd_score)[m
[32m+[m[41m        [m
[32m+[m[32m        # Regime Changes[m
[32m+[m[32m        regimes = battle_stats.get("regime_changes_adapted", 0)[m
[32m+[m[32m        if regimes >= t.min_regime_changes:[m
[32m+[m[32m            strengths.append(f"ADAPTIVE: Handled {regimes} regime changes")[m
[32m+[m[32m        regime_score = min(100, regimes / t.min_regime_changes * 100)[m
[32m+[m[32m        scores.append(regime_score)[m
[32m+[m[41m        [m
[32m+[m[32m        # Black Swans[m
[32m+[m[32m        swans = battle_stats.get("black_swans_handled", 0)[m
[32m+[m[32m        if swans >= t.min_black_swans:[m
[32m+[m[32m            strengths.append(f"ANTIFRAGILE: Survived {swans} black swans")[m
[32m+[m[32m        else:[m
[32m+[m[32m            warnings.append(f"FRAGILE: No black swan experience")[m
[32m+[m[32m        swan_score = min(100, swans / t.min_black_swans * 100) if t.min_black_swans > 0 else 50[m
[32m+[m[32m        scores.append(swan_score)[m
[32m+[m[41m        [m
[32m+[m[32m        # Learning Events[m
[32m+[m[32m        learning = stats.get("learning", {})[m
[32m+[m[32m        events = learning.get("total_outcomes", 0)[m
[32m+[m[32m        if events < t.min_learning_events:[m
[32m+[m[32m            warnings.append(f"INSUFFICIENT LEARNING: {events} < {t.min_learning_events}")[m
[32m+[m[32m        learning_score = min(100, events / t.min_learning_events * 100)[m
[32m+[m[32m        scores.append(learning_score)[m
[32m+[m[41m        [m
[32m+[m[32m        return sum(scores) / len(scores) if scores else 50, failures, warnings, strengths[m
[32m+[m[41m    [m
[32m+[m[32m    def _grade_capabilities([m
[32m+[m[32m        self, stats: Dict, t: InstitutionalThresholds, category: AgentCategory[m
[32m+[m[32m    ) -> Tuple[float, List[str], List[str], List[str]]:[m
[32m+[m[32m        """Grade capabilities."""[m
[32m+[m[32m        failures, warnings, strengths = [], [], [][m
[32m+[m[41m        [m
[32m+[m[32m        capabilities = stats.get("capabilities", [])[m
[32m+[m[32m        cap_count = len(capabilities) if isinstance(capabilities, list) else 0[m
[32m+[m[41m        [m
[32m+[m[32m        # Category-specific thresholds[m
[32m+[m[32m        if category == AgentCategory.MASTER:[m
[32m+[m[32m            required = t.min_capabilities_master[m
[32m+[m[32m        elif category == AgentCategory.SENIOR:[m
[32m+[m[32m            required = t.min_capabilities_senior[m
[32m+[m[32m        else:[m
[32m+[m[32m            required = t.min_capabilities_standard[m
[32m+[m[41m        [m
[32m+[m[32m        if cap_count < required:[m
[32m+[m[32m            warnings.append(f"UNDERPOWERED: {cap_count} capabilities < {required}")[m
[32m+[m[32m        elif cap_count >= required * 1.5:[m
[32m+[m[32m            strengths.append(f"VERSATILE: {cap_count} capabilities")[m
[32m+[m[41m        [m
[32m+[m[32m        score = min(100, cap_count / required * 100)[m
[32m+[m[41m        [m
[32m+[m[32m        return score, failures, warnings, strengths[m
[32m+[m[41m    [m
[32m+[m[32m    def _grade_calibration([m
[32m+[m[32m        self, stats: Dict, t: InstitutionalThresholds[m
[32m+[m[32m    ) -> Tuple[float, List[str], List[str], List[str]]:[m
[32m+[m[32m        """Grade confidence calibration."""[m
[32m+[m[32m        failures, warnings, strengths = [], [], [][m
[32m+[m[41m        [m
[32m+[m[32m        calibration = stats.get("confidence_calibration", stats.get("calibration", 0.8))[m
[32m+[m[32m        overconfidence = stats.get("overconfidence", 0.1)[m
[32m+[m[41m        [m
[32m+[m[32m        if calibration < t.min_confidence_calibration:[m
[32m+[m[32m            warnings.append(f"POORLY CALIBRATED: {calibration:.0%}")[m
[32m+[m[32m        elif calibration >= 0.90:[m
[32m+[m[32m            strengths.append(f"WELL CALIBRATED: {calibration:.0%}")[m
[32m+[m[41m        [m
[32m+[m[32m        if overconfidence > t.max_overconfidence:[m
[32m+[m[32m            failures.append(f"OVERCONFIDENT: {overconfidence:.0%} > {t.max_overconfidence:.0%}")[m
[32m+[m[41m        [m
[32m+[m[32m        score = min(100, calibration * 100)[m
[32m+[m[41m        [m
[32m+[m[32m        return score, failures, warnings, strengths[m
[32m+[m[41m    [m
[32m+[m[32m    def _grade_consistency([m
[32m+[m[32m        self, stats: Dict, t: InstitutionalThresholds[m
[32m+[m[32m    ) -> Tuple[float, List[str], List[str], List[str]]:[m
[32m+[m[32m        """Grade consistency over time."""[m
[32m+[m[32m        failures, warnings, strengths = [], [], [][m
[32m+[m[32m        scores = [][m
[32m+[m[41m        [m
[32m+[m[32m        # CV Standard Deviation[m
[32m+[m[32m        cv_std = stats.get("cv_std", stats.get("cv_auc_std", 0.03))[m
[32m+[m[32m        if cv_std > t.max_cv_std:[m
[32m+[m[32m            warnings.append(f"INCONSISTENT: CV std {cv_std:.2%} > {t.max_cv_std:.0%}")[m
[32m+[m[32m        elif cv_std <= 0.03:[m
[32m+[m[32m            strengths.append(f"STABLE: CV std {cv_std:.2%}")[m
[32m+[m[32m        cv_score = min(100, max(0, (1 - cv_std / 0.10) * 100))[m
[32m+[m[32m        scores.append(cv_score)[m
[32m+[m[41m        [m
[32m+[m[32m        # Out-of-Sample Degradation[m
[32m+[m[32m        oos_deg = stats.get("oos_degradation", 0.05)[m
[32m+[m[32m        if oos_deg > t.max_oos_degradation:[m
[32m+[m[32m            failures.append(f"OVERFITTING: OOS {oos_deg:.1%} worse than train")[m
[32m+[m[32m        oos_score = min(100, max(0, (1 - oos_deg / 0.15) * 100))[m
[32m+[m[32m        scores.append(oos_score)[m
[32m+[m[41m        [m
[32m+[m[32m        return sum(scores) / len(scores) if scores else 75, failures, warnings, strengths[m
[32m+[m[41m    [m
[32m+[m[32m    def _determine_grade([m
[32m+[m[32m        self,[m
[32m+[m[32m        score: float,[m
[32m+[m[32m        critical_failures: List[str],[m
[32m+[m[32m        warnings: List[str],[m
[32m+[m[32m        category: AgentCategory[m
[32m+[m[32m    ) -> Tuple[GradeLevel, bool, str, str]:[m
[32m+[m[32m        """Determine final grade and promotion status."""[m
[32m+[m[41m        [m
[32m+[m[32m        # ANY critical failure = immediate action[m
[32m+[m[32m        if critical_failures:[m
[32m+[m[32m            if len(critical_failures) >= 3:[m
[32m+[m[32m                return GradeLevel.F, False, "BLACKLISTED", \[m
[32m+[m[32m                    f"BLACKLIST: {len(critical_failures)} critical failures"[m
[32m+[m[32m            elif len(critical_failures) >= 1:[m
[32m+[m[32m                return GradeLevel.D, False, "TERMINATED", \[m
[32m+[m[32m                    f"TERMINATE: {critical_failures[0]}"[m
[32m+[m[41m        [m
[32m+[m[32m        # Many warnings = probation[m
[32m+[m[32m        if len(warnings) >= 5:[m
[32m+[m[32m            return GradeLevel.C, False, "PROBATION", \[m
[32m+[m[32m                f"PROBATION: {len(warnings)} warnings - 24hr to improve"[m
[32m+[m[41m        [m
[32m+[m[32m        # Score-based grading[m
[32m+[m[32m        if score >= 95:[m
[32m+[m[32m            return GradeLevel.S_PLUS, True, "LIVE", \[m
[32m+[m[32m                "CITADEL ELITE: Immediate live deployment"[m
[32m+[m[32m        elif score >= 90:[m
[32m+[m[32m            return GradeLevel.S, True, "LIVE", \[m
[32m+[m[32m                "GOLDMAN TIER: Ready for live trading"[m
[32m+[m[32m        elif score >= 85:[m
[32m+[m[32m            return GradeLevel.A_PLUS, True, "LIVE", \[m
[32m+[m[32m                "INSTITUTIONAL: Approved for live trading"[m
[32m+[m[32m        elif score >= 80:[m
[32m+[m[32m            return GradeLevel.A, True, "PAPER", \[m
[32m+[m[32m                "INSTITUTIONAL: Approved for paper trading"[m
[32m+[m[32m        elif score >= 70:[m
[32m+[m[32m            return GradeLevel.B_PLUS, False, "TRAINING", \[m
[32m+[m[32m                "PROMISING: Continue training with priority"[m
[32m+[m[32m        elif score >= 60:[m
[32m+[m[32m            return GradeLevel.B, False, "TRAINING", \[m
[32m+[m[32m                "ACCEPTABLE: Continue standard training"[m
[32m+[m[32m        else:[m
[32m+[m[32m            return GradeLevel.C, False, "PROBATION", \[m
[32m+[m[32m                f"BELOW STANDARD: Score {score:.0f}/100 needs work"[m
[32m+[m[41m    [m
[32m+[m[32m    def _identify_improvements([m
[32m+[m[32m        self, pred: float, risk: float, trade: float,[m
[32m+[m[32m        exp: float, cap: float, cal: float, con: float[m
[32m+[m[32m    ) -> List[str]:[m
[32m+[m[32m        """Identify areas needing improvement."""[m
[32m+[m[32m        improvements = [][m
[32m+[m[41m        [m
[32m+[m[32m        scores = [[m
[32m+[m[32m            ("Prediction Quality", pred),[m
[32m+[m[32m            ("Risk Management", risk),[m
[32m+[m[32m            ("Trading Performance", trade),[m
[32m+[m[32m            ("Battle Experience", exp),[m
[32m+[m[32m            ("Capabilities", cap),[m
[32m+[m[32m            ("Calibration", cal),[m
[32m+[m[32m            ("Consistency", con),[m
[32m+[m[32m        ][m
[32m+[m[41m        [m
[32m+[m[32m        # Sort by lowest score[m
[32m+[m[32m        scores.sort(key=lambda x: x[1])[m
[32m+[m[41m        [m
[32m+[m[32m        for name, score in scores[:3]:  # Top 3 weakest areas[m
[32m+[m[32m            if score < 70:[m
[32m+[m[32m                improvements.append(f"CRITICAL: {name} ({score:.0f}/100)")[m
[32m+[m[32m            elif score < 80:[m
[32m+[m[32m                improvements.append(f"IMPROVE: {name} ({score:.0f}/100)")[m
[32m+[m[41m        [m
[32m+[m[32m        return improvements[m
[32m+[m
[32m+[m
[32m+[m[32m# =============================================================================[m
[32m+[m[32m# CONVENIENCE FUNCTIONS[m
[32m+[m[32m# =============================================================================[m
[32m+[m
[32m+[m[32mdef grade_agent_institutional([m
[32m+[m[32m    agent_id: str,[m
[32m+[m[32m    agent_name: str,[m
[32m+[m[32m    category: str,[m
[32m+[m[32m    stats: Dict[str, Any][m
[32m+[m[32m) -> Dict[str, Any]:[m
[32m+[m[32m    """[m
[32m+[m[32m    Convenience wrapper for institutional grading.[m
[32m+[m[41m    [m
[32m+[m[32m    Usage:[m
[32m+[m[32m        from src.core.institutional_grading import grade_agent_institutional[m
[32m+[m[41m        [m
[32m+[m[32m        result = grade_agent_institutional([m
[32m+[m[32m            agent_id="ghost_001",[m
[32m+[m[32m            agent_name="GhostAgent",[m
[32m+[m[32m            category="master",[m
[32m+[m[32m            stats=agent.get_stats()[m
[32m+[m[32m        )[m
[32m+[m[41m        [m
[32m+[m[32m        print(f"Grade: {result['grade']}")[m
[32m+[m[32m        print(f"Promoted: {result['promoted']}")[m
[32m+[m[32m        print(f"Level: {result['promotion_level']}")[m
[32m+[m[32m    """[m
[32m+[m[32m    grader = InstitutionalGrader()[m
[32m+[m[41m    [m
[32m+[m[32m    cat = AgentCategory(category.lower())[m
[32m+[m[41m    [m
[32m+[m[32m    report = grader.grade_agent([m
[32m+[m[32m        agent_id=agent_id,[m
[32m+[m[32m        agent_name=agent_name,[m
[32m+[m[32m        category=cat,[m
[32m+[m[32m        stats=stats[m
[32m+[m[32m    )[m
[32m+[m[41m    [m
[32m+[m[32m    return report.to_dict()[m
[32m+[m
[32m+[m
[32m+[m[32mdef get_grade_requirements() -> Dict[str, Any]:[m
[32m+[m[32m    """Get all grading requirements for documentation."""[m
[32m+[m[32m    t = InstitutionalThresholds()[m
[32m+[m[41m    [m
[32m+[m[32m    return {[m
[32m+[m[32m        "prediction": {[m
[32m+[m[32m            "auc_live": t.min_auc_live,[m
[32m+[m[32m            "auc_paper": t.min_auc_paper,[m
[32m+[m[32m            "auc_training": t.min_auc_training,[m
[32m+[m[32m            "accuracy_live": t.min_accuracy_live,[m
[32m+[m[32m            "accuracy_paper": t.min_accuracy_paper,[m
[32m+[m[32m            "precision": t.min_precision,[m
[32m+[m[32m        },[m
[32m+[m[32m        "risk": {[m
[32m+[m[32m            "sharpe_live": t.min_sharpe_live,[m
[32m+[m[32m            "sharpe_paper": t.min_sharpe_paper,[m
[32m+[m[32m            "sortino": t.min_sortino,[m
[32m+[m[32m            "calmar": t.min_calmar,[m
[32m+[m[32m            "max_drawdown_live": t.max_drawdown_live,[m
[32m+[m[32m            "max_drawdown_paper": t.max_drawdown_paper,[m
[32m+[m[32m            "var_95": t.max_var_95,[m
[32m+[m[32m        },[m
[32m+[m[32m        "trading": {[m
[32m+[m[32m            "win_rate": t.min_win_rate,[m
[32m+[m[32m            "profit_factor": t.min_profit_factor,[m
[32m+[m[32m            "trades_live": t.min_trades_live,[m
[32m+[m[32m            "trades_paper": t.min_trades_paper,[m
[32m+[m[32m        },[m
[32m+[m[32m        "experience": {[m
[32m+[m[32m            "crashes_survived": t.min_crashes_survived,[m
[32m+[m[32m            "drawdowns_navigated": t.min_drawdowns_navigated,[m
[32m+[m[32m            "regime_changes": t.min_regime_changes,[m
[32m+[m[32m            "black_swans": t.min_black_swans,[m
[32m+[m[32m            "learning_events": t.min_learning_events,[m
[32m+[m[32m        },[m
[32m+[m[32m        "grade_scale": {[m
[32m+[m[32m            "S+": "95+ (Citadel Elite - Top 0.1%)",[m
[32m+[m[32m            "S": "90-94 (Goldman/Renaissance - Top 1%)",[m
[32m+[m[32m            "A+": "85-89 (Institutional - Live Trading)",[m
[32m+[m[32m            "A": "80-84 (Institutional - Paper Trading)",[m
[32m+[m[32m            "B+": "70-79 (Promising - Priority Training)",[m
[32m+[m[32m            "B": "60-69 (Acceptable - Standard Training)",[m
[32m+[m[32m            "C": "50-59 (Probation - 24hr to improve)",[m
[32m+[m[32m            "D": "<50 (Terminated)",[m
[32m+[m[32m            "F": "Critical Failures (Blacklisted)",[m
[32m+[m[32m        }[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m
[32m+[m[32m# =============================================================================[m
[32m+[m[32m# MAIN[m
[32m+[m[32m# =============================================================================[m
[32m+[m
[32m+[m[32mif __name__ == "__main__":[m
[32m+[m[32m    # Example usage[m
[32m+[m[32m    print("=" * 70)[m
[32m+[m[32m    print("INSTITUTIONAL GRADING SYSTEM - REQUIREMENTS")[m
[32m+[m[32m    print("=" * 70)[m
[32m+[m[41m    [m
[32m+[m[32m    reqs = get_grade_requirements()[m
[32m+[m[41m    [m
[32m+[m[32m    print("\nðŸ“Š PREDICTION REQUIREMENTS:")[m
[32m+[m[32m    for k, v in reqs["prediction"].items():[m
[32m+[m[32m        print(f"  {k}: {v}")[m
[32m+[m[41m    [m
[32m+[m[32m    print("\nâš ï¸ RISK REQUIREMENTS:")[m
[32m+[m[32m    for k, v in reqs["risk"].items():[m
[32m+[m[32m        print(f"  {k}: {v}")[m
[32m+[m[41m    [m
[32m+[m[32m    print("\nðŸ’¹ TRADING REQUIREMENTS:")[m
[32m+[m[32m    for k, v in reqs["trading"].items():[m
[32m+[m[32m        print(f"  {k}: {v}")[m
[32m+[m[41m    [m
[32m+[m[32m    print("\nðŸŽ–ï¸ EXPERIENCE REQUIREMENTS:")[m
[32m+[m[32m    for k, v in reqs["experience"].items():[m
[32m+[m[32m        print(f"  {k}: {v}")[m
[32m+[m[41m    [m
[32m+[m[32m    print("\nðŸ“‹ GRADE SCALE:")[m
[32m+[m[32m    for grade, desc in reqs["grade_scale"].items():[m
[32m+[m[32m        print(f"  {grade}: {desc}")[m
[32m+[m[41m    [m
[32m+[m[32m    print("\n" + "=" * 70)[m
[32m+[m[32m    print("Only the ELITE survive. No participation trophies.")[m
[32m+[m[32m    print("=" * 70)[m
[32m+[m
[32m+[m
[1mdiff --git a/scripts/HYDRATE_ALPHA_VANTAGE.bat b/scripts/HYDRATE_ALPHA_VANTAGE.bat[m
[1mnew file mode 100644[m
[1mindex 00000000..b00a158b[m
[1m--- /dev/null[m
[1m+++ b/scripts/HYDRATE_ALPHA_VANTAGE.bat[m
[36m@@ -0,0 +1,68 @@[m
[32m+[m[32m@echo off[m
[32m+[m[32mREM ============================================================================[m
[32m+[m[32mREM ALPHA VANTAGE DATA HYDRATION[m
[32m+[m[32mREM ============================================================================[m
[32m+[m[32mREM This script pulls market data from Alpha Vantage Premium API.[m
[32m+[m[32mREM[m
[32m+[m[32mREM WHAT IT PULLS:[m
[32m+[m[32mREM   - Stock daily prices (20+ years history)[m
[32m+[m[32mREM   - Stock fundamentals (30+ valuation metrics)[m
[32m+[m[32mREM   - Forex pairs (10 major pairs)[m
[32m+[m[32mREM[m
[32m+[m[32mREM RATE LIMITS: 75 calls/minute (Premium tier)[m
[32m+[m[32mREM EXPECTED TIME: 2-4 hours for full hydration[m
[32m+[m[32mREM[m
[32m+[m[32mREM OUTPUTS:[m
[32m+[m[32mREM   - SQL: price_bars, fundamentals, forex_bars tables[m
[32m+[m[32mREM   - CSV Backup: data/csv_backup/alpha_vantage/[m
[32m+[m[32mREM   - Log: logs/alpha_vantage_hydration.log[m
[32m+[m[32mREM ============================================================================[m
[32m+[m
[32m+[m[32mecho ============================================================================[m
[32m+[m[32mecho ALPHA VANTAGE DATA HYDRATION[m
[32m+[m[32mecho ============================================================================[m
[32m+[m[32mecho.[m
[32m+[m
[32m+[m[32mcd /d "%~dp0.."[m
[32m+[m
[32m+[m[32mecho Activating virtual environment...[m
[32m+[m[32mcall venv\Scripts\activate[m
[32m+[m
[32m+[m[32mecho.[m
[32m+[m[32mecho Choose an option:[m
[32m+[m[32mecho   1. Full hydration (2-4 hours)[m
[32m+[m[32mecho   2. Quick test (10 stocks, ~15 minutes)[m
[32m+[m[32mecho   3. Stocks only[m
[32m+[m[32mecho   4. Fundamentals only[m
[32m+[m[32mecho   5. Forex only[m
[32m+[m[32mecho.[m
[32m+[m
[32m+[m[32mset /p choice="Enter choice (1-5): "[m
[32m+[m
[32m+[m[32mif "%choice%"=="1" ([m
[32m+[m[32m    echo Running full hydration...[m
[32m+[m[32m    python scripts/hydrate_alpha_vantage.py[m
[32m+[m[32m) else if "%choice%"=="2" ([m
[32m+[m[32m    echo Running quick test...[m
[32m+[m[32m    python scripts/hydrate_alpha_vantage.py --quick[m
[32m+[m[32m) else if "%choice%"=="3" ([m
[32m+[m[32m    echo Hydrating stocks...[m
[32m+[m[32m    python scripts/hydrate_alpha_vantage.py --stocks-only[m
[32m+[m[32m) else if "%choice%"=="4" ([m
[32m+[m[32m    echo Hydrating fundamentals...[m
[32m+[m[32m    python scripts/hydrate_alpha_vantage.py --fundamentals-only[m
[32m+[m[32m) else if "%choice%"=="5" ([m
[32m+[m[32m    echo Hydrating forex...[m
[32m+[m[32m    python scripts/hydrate_alpha_vantage.py --forex-only[m
[32m+[m[32m) else ([m
[32m+[m[32m    echo Invalid choice. Running full hydration...[m
[32m+[m[32m    python scripts/hydrate_alpha_vantage.py[m
[32m+[m[32m)[m
[32m+[m
[32m+[m[32mecho.[m
[32m+[m[32mecho ============================================================================[m
[32m+[m[32mecho Hydration complete! Check logs/alpha_vantage_hydration.log for details.[m
[32m+[m[32mecho ============================================================================[m
[32m+[m
[32m+[m[32mpause[m
[32m+[m
[1mdiff --git a/scripts/INGEST_RESEARCH.bat b/scripts/INGEST_RESEARCH.bat[m
[1mnew file mode 100644[m
[1mindex 00000000..b383d861[m
[1m--- /dev/null[m
[1m+++ b/scripts/INGEST_RESEARCH.bat[m
[36m@@ -0,0 +1,48 @@[m
[32m+[m[32m@echo off[m
[32m+[m[32mREM ============================================================================[m
[32m+[m[32mREM RESEARCH DOCUMENT INGESTION[m
[32m+[m[32mREM ============================================================================[m
[32m+[m[32mREM This script ingests research documents into a vector store for semantic search.[m
[32m+[m[32mREM[m
[32m+[m[32mREM SUPPORTED FILE TYPES:[m
[32m+[m[32mREM   .txt, .md   - Plain text and markdown[m
[32m+[m[32mREM   .pdf        - PDF documents[m
[32m+[m[32mREM   .docx       - Microsoft Word[m
[32m+[m[32mREM   .csv        - Spreadsheets[m
[32m+[m[32mREM[m
[32m+[m[32mREM WHAT IT DOES:[m
[32m+[m[32mREM   1. Reads all files from configured research paths[m
[32m+[m[32mREM   2. Chunks documents into pieces[m
[32m+[m[32mREM   3. Generates embeddings using sentence transformers[m
[32m+[m[32mREM   4. Saves to FAISS vector store[m
[32m+[m[32mREM[m
[32m+[m[32mREM OUTPUTS:[m
[32m+[m[32mREM   - Vector store: data/vectorstore/[m
[32m+[m[32mREM   - Log: logs/ingest_research.log[m
[32m+[m[32mREM ============================================================================[m
[32m+[m
[32m+[m[32mecho ============================================================================[m
[32m+[m[32mecho RESEARCH DOCUMENT INGESTION[m
[32m+[m[32mecho ============================================================================[m
[32m+[m[32mecho.[m
[32m+[m
[32m+[m[32mcd /d "%~dp0.."[m
[32m+[m
[32m+[m[32mecho Activating virtual environment...[m
[32m+[m[32mcall venv\Scripts\activate[m
[32m+[m
[32m+[m[32mecho.[m
[32m+[m[32mecho Starting document ingestion...[m
[32m+[m[32mecho This will process all documents in your configured research paths.[m
[32m+[m[32mecho.[m
[32m+[m
[32m+[m[32mpython scripts/ingest_research.py[m
[32m+[m
[32m+[m[32mecho.[m
[32m+[m[32mecho ============================================================================[m
[32m+[m[32mecho Ingestion complete! Check logs/ingest_research.log for details.[m
[32m+[m[32mecho Vector store saved to data/vectorstore/[m
[32m+[m[32mecho ============================================================================[m
[32m+[m
[32m+[m[32mpause[m
[32m+[m
[1mdiff --git a/scripts/TRAIN_ALL_AGENTS.bat b/scripts/TRAIN_ALL_AGENTS.bat[m
[1mnew file mode 100644[m
[1mindex 00000000..e7507d21[m
[1m--- /dev/null[m
[1m+++ b/scripts/TRAIN_ALL_AGENTS.bat[m
[36m@@ -0,0 +1,44 @@[m
[32m+[m[32m@echo off[m
[32m+[m[32mREM ============================================================================[m
[32m+[m[32mREM TRAIN ALL AGENTS[m
[32m+[m[32mREM ============================================================================[m
[32m+[m[32mREM This script trains ALL agents using the elite grading system.[m
[32m+[m[32mREM[m[41m [m
[32m+[m[32mREM WHAT IT DOES:[m
[32m+[m[32mREM   1. Activates the virtual environment[m
[32m+[m[32mREM   2. Runs the agent trainer on all configured agents[m
[32m+[m[32mREM   3. Grades each agent using elite thresholds[m
[32m+[m[32mREM   4. Saves results to data/training_results/[m
[32m+[m[32mREM[m
[32m+[m[32mREM EXPECTED TIME: 1-4 hours depending on data volume[m
[32m+[m[32mREM[m
[32m+[m[32mREM OUTPUTS:[m
[32m+[m[32mREM   - Training results: data/training_results/*.json[m
[32m+[m[32mREM   - Log file: logs/agent_training.log[m
[32m+[m[32mREM ============================================================================[m
[32m+[m
[32m+[m[32mecho ============================================================================[m
[32m+[m[32mecho AGENT TRAINING SYSTEM[m
[32m+[m[32mecho ============================================================================[m
[32m+[m[32mecho.[m
[32m+[m
[32m+[m[32mcd /d "%~dp0.."[m
[32m+[m
[32m+[m[32mecho Activating virtual environment...[m
[32m+[m[32mcall venv\Scripts\activate[m
[32m+[m
[32m+[m[32mecho.[m
[32m+[m[32mecho Starting agent training...[m
[32m+[m[32mecho This will train all agents and grade them using elite thresholds.[m
[32m+[m[32mecho.[m
[32m+[m
[32m+[m[32mpython -m src.training.agent_trainer --all[m
[32m+[m
[32m+[m[32mecho.[m
[32m+[m[32mecho ============================================================================[m
[32m+[m[32mecho Training complete! Check logs/agent_training.log for details.[m
[32m+[m[32mecho Results saved to data/training_results/[m
[32m+[m[32mecho ============================================================================[m
[32m+[m
[32m+[m[32mpause[m
[32m+[m
[1mdiff --git a/scripts/hydrate_alpha_vantage.py b/scripts/hydrate_alpha_vantage.py[m
[1mnew file mode 100644[m
[1mindex 00000000..1c7b8e52[m
[1m--- /dev/null[m
[1m+++ b/scripts/hydrate_alpha_vantage.py[m
[36m@@ -0,0 +1,412 @@[m
[32m+[m[32m"""[m
[32m+[m[32m================================================================================[m
[32m+[m[32mALPHA VANTAGE DATA HYDRATION[m
[32m+[m[32m================================================================================[m
[32m+[m
[32m+[m[32mWHAT THIS DOES:[m
[32m+[m[32m    Pulls comprehensive market data from Alpha Vantage Premium API:[m
[32m+[m[32m    - Stock price data (intraday 1min, 5min, daily)[m
[32m+[m[32m    - Fundamental data (P/E, EV/EBITDA, margins, growth rates)[m
[32m+[m[32m    - Forex pairs (EUR/USD, GBP/USD, etc.)[m
[32m+[m[32m    - Index data (SPX, NDX, DJI)[m
[32m+[m[32m    - Earnings calendars and estimates[m
[32m+[m
[32m+[m[32mWHY USE ALPHA VANTAGE:[m
[32m+[m[32m    - Premium tier: 75 API calls/minute (vs 5 for free)[m
[32m+[m[32m    - Up to 20+ years of daily data[m
[32m+[m[32m    - Up to 2 years of intraday data[m
[32m+[m[32m    - Fundamental data unavailable elsewhere[m
[32m+[m[32m    - Good for US small/mid cap companies[m
[32m+[m
[32m+[m[32mRATE LIMITS:[m
[32m+[m[32m    - Premium: 75 calls/minute, 500 calls/day (can request more)[m
[32m+[m[32m    - This script enforces 12-second delays to stay safe[m
[32m+[m
[32m+[m[32mWHAT IT PULLS:[m
[32m+[m[32m    1. STOCKS: Daily adjusted (20+ years), Intraday (2 years)[m
[32m+[m[32m    2. FUNDAMENTALS: Company overview with 30+ valuation metrics[m
[32m+[m[32m    3. FOREX: Major currency pairs[m
[32m+[m[32m    4. INDICES: SPX, NDX, DJI (via proxy ETFs)[m
[32m+[m[32m    5. EARNINGS: Upcoming earnings dates and estimates[m
[32m+[m
[32m+[m[32m================================================================================[m
[32m+[m[32mHOW TO USE:[m
[32m+[m[32m================================================================================[m
[32m+[m
[32m+[m[32mSTEP 1: Make sure your .env has Alpha Vantage API key:[m
[32m+[m[32m    ALPHA_VANTAGE_API_KEY=your_key_here[m
[32m+[m
[32m+[m[32mSTEP 2: Activate virtual environment:[m
[32m+[m
[32m+[m[32m    Windows (PowerShell):[m
[32m+[m[32m    ---------------------[m
[32m+[m[32m    cd C:\\Users\\tom\\Alpha-Loop-LLM\\Alpha-Loop-LLM-1[m
[32m+[m[32m    .\\venv\\Scripts\\activate[m
[32m+[m
[32m+[m[32m    Mac (Terminal):[m
[32m+[m[32m    ---------------[m
[32m+[m[32m    cd ~/Alpha-Loop-LLM/Alpha-Loop-LLM-1[m
[32m+[m[32m    source venv/bin/activate[m
[32m+[m
[32m+[m[32mSTEP 3: Run hydration:[m
[32m+[m
[32m+[m[32m    # Full hydration (takes 2-4 hours due to rate limits)[m
[32m+[m[32m    python scripts/hydrate_alpha_vantage.py[m
[32m+[m
[32m+[m[32m    # Quick test (10-15 minutes)[m
[32m+[m[32m    python scripts/hydrate_alpha_vantage.py --quick[m
[32m+[m
[32m+[m[32m    # Specific asset class[m
[32m+[m[32m    python scripts/hydrate_alpha_vantage.py --stocks-only[m
[32m+[m[32m    python scripts/hydrate_alpha_vantage.py --forex-only[m
[32m+[m[32m    python scripts/hydrate_alpha_vantage.py --fundamentals-only[m
[32m+[m
[32m+[m[32mSTEP 4: Check outputs:[m
[32m+[m[32m    - Data saved to Azure SQL (price_bars, fundamentals tables)[m
[32m+[m[32m    - Backup CSVs in data/csv_backup/[m
[32m+[m[32m    - Log file: logs/alpha_vantage_hydration.log[m
[32m+[m
[32m+[m[32m================================================================================[m
[32m+[m[32mDATA STORED:[m
[32m+[m[32m================================================================================[m
[32m+[m
[32m+[m[32mprice_bars table:[m
[32m+[m[32m    symbol, timestamp, open, high, low, close, volume, source, asset_type[m
[32m+[m
[32m+[m[32mfundamentals table:[m
[32m+[m[32m    symbol, timestamp, pe_ratio, peg_ratio, price_to_book, price_to_sales,[m
[32m+[m[32m    ev_to_revenue, ev_to_ebitda, profit_margin, operating_margin, etc.[m
[32m+[m
[32m+[m[32mforex_bars table:[m
[32m+[m[32m    symbol, timestamp, open, high, low, close, source[m
[32m+[m
[32m+[m[32m================================================================================[m
[32m+[m[32m"""[m
[32m+[m
[32m+[m[32mimport os[m
[32m+[m[32mimport sys[m
[32m+[m[32mimport time[m
[32m+[m[32mimport argparse[m
[32m+[m[32mfrom pathlib import Path[m
[32m+[m[32mfrom datetime import datetime[m
[32m+[m[32mfrom typing import List, Dict, Optional[m
[32m+[m[32mfrom concurrent.futures import ThreadPoolExecutor[m
[32m+[m
[32m+[m[32mimport pandas as pd[m
[32m+[m[32mfrom loguru import logger[m
[32m+[m
[32m+[m[32m# Add project root[m
[32m+[m[32mPROJECT_ROOT = Path(__file__).parent.parent[m
[32m+[m[32msys.path.insert(0, str(PROJECT_ROOT))[m
[32m+[m
[32m+[m[32mfrom src.config.settings import get_settings[m
[32m+[m[32mfrom src.database.connection import get_engine[m
[32m+[m[32mfrom src.data_ingestion.sources.alpha_vantage_premium import ([m
[32m+[m[32m    AlphaVantagePremium,[m
[32m+[m[32m    get_av_premium[m
[32m+[m[32m)[m
[32m+[m
[32m+[m
[32m+[m[32mclass AlphaVantageHydrator:[m
[32m+[m[32m    """[m
[32m+[m[32m    Comprehensive Alpha Vantage data hydration.[m
[32m+[m[32m    """[m
[32m+[m[41m    [m
[32m+[m[32m    def __init__(self):[m
[32m+[m[32m        self.settings = get_settings()[m
[32m+[m[32m        self.engine = get_engine()[m
[32m+[m[32m        self.av = get_av_premium()[m
[32m+[m[41m        [m
[32m+[m[32m        # Check API key[m
[32m+[m[32m        if not self.settings.alpha_vantage_api_key:[m
[32m+[m[32m            raise ValueError([m
[32m+[m[32m                "Alpha Vantage API key not found!\n"[m
[32m+[m[32m                "Add ALPHA_VANTAGE_API_KEY to your .env file"[m
[32m+[m[32m            )[m
[32m+[m[41m        [m
[32m+[m[32m        self.stats = {[m
[32m+[m[32m            "stocks_daily": 0,[m
[32m+[m[32m            "stocks_intraday": 0,[m
[32m+[m[32m            "fundamentals": 0,[m
[32m+[m[32m            "forex": 0,[m
[32m+[m[32m            "indices": 0,[m
[32m+[m[32m            "errors": 0,[m
[32m+[m[32m            "rows_saved": 0,[m
[32m+[m[32m        }[m
[32m+[m[41m        [m
[32m+[m[32m        # Create backup directory[m
[32m+[m[32m        self.backup_dir = Path(self.settings.data_dir) / "csv_backup" / "alpha_vantage"[m
[32m+[m[32m        self.backup_dir.mkdir(parents=True, exist_ok=True)[m
[32m+[m[41m        [m
[32m+[m[32m        logger.info("=" * 70)[m
[32m+[m[32m        logger.info("ALPHA VANTAGE DATA HYDRATION")[m
[32m+[m[32m        logger.info("=" * 70)[m
[32m+[m[32m        logger.info(f"API Key: {self.settings.alpha_vantage_api_key[:8]}...")[m
[32m+[m[32m        logger.info(f"Backup dir: {self.backup_dir}")[m
[32m+[m[41m    [m
[32m+[m[32m    def get_target_stocks(self, limit: Optional[int] = None) -> List[str]:[m
[32m+[m[32m        """Get list of stocks to hydrate."""[m
[32m+[m[32m        # Default universe: US small/mid cap focus[m
[32m+[m[32m        # You can customize this list[m
[32m+[m[32m        stocks = [[m
[32m+[m[32m            # Large Cap Tech[m
[32m+[m[32m            "AAPL", "MSFT", "GOOGL", "META", "AMZN", "NVDA", "AMD", "TSLA",[m
[32m+[m[32m            "NFLX", "ADBE", "CRM", "ORCL", "INTC", "CSCO", "QCOM", "TXN",[m
[32m+[m[41m            [m
[32m+[m[32m            # Financials[m
[32m+[m[32m            "JPM", "BAC", "WFC", "GS", "MS", "C", "AXP", "V", "MA", "PYPL",[m
[32m+[m[32m            "SQ", "COIN", "HOOD", "SCHW", "BLK", "BX", "KKR",[m
[32m+[m[41m            [m
[32m+[m[32m            # Healthcare[m
[32m+[m[32m            "JNJ", "UNH", "PFE", "MRK", "ABBV", "LLY", "TMO", "DHR", "BMY",[m
[32m+[m[32m            "AMGN", "GILD", "MRNA", "BNTX", "REGN", "VRTX",[m
[32m+[m[41m            [m
[32m+[m[32m            # Consumer[m
[32m+[m[32m            "WMT", "COST", "HD", "LOW", "TGT", "NKE", "SBUX", "MCD", "DIS",[m
[32m+[m[32m            "CMCSA", "NFLX", "ABNB", "UBER", "LYFT", "DASH",[m
[32m+[m[41m            [m
[32m+[m[32m            # Energy[m
[32m+[m[32m            "XOM", "CVX", "COP", "OXY", "SLB", "HAL", "EOG", "MPC", "VLO",[m
[32m+[m[41m            [m
[32m+[m[32m            # Industrials[m
[32m+[m[32m            "BA", "CAT", "GE", "MMM", "HON", "UPS", "FDX", "LMT", "RTX",[m
[32m+[m[41m            [m
[32m+[m[32m            # Small/Mid Cap (your focus)[m
[32m+[m[32m            "DDOG", "NET", "ZS", "CRWD", "SNOW", "MDB", "PLTR", "U", "RBLX",[m
[32m+[m[32m            "AFRM", "SOFI", "UPST", "OPEN", "HOOD", "RIVN", "LCID",[m
[32m+[m[32m            "AI", "PATH", "GTLB", "CFLT", "SAMSARA", "DUOL",[m
[32m+[m[41m            [m
[32m+[m[32m            # ETFs for indices[m
[32m+[m[32m            "SPY", "QQQ", "IWM", "DIA", "VTI", "VOO",[m
[32m+[m[32m        ][m
[32m+[m[41m        [m
[32m+[m[32m        if limit:[m
[32m+[m[32m            return stocks[:limit][m
[32m+[m[32m        return stocks[m
[32m+[m[41m    [m
[32m+[m[32m    def get_forex_pairs(self) -> List[tuple]:[m
[32m+[m[32m        """Get forex pairs to hydrate."""[m
[32m+[m[32m        return [[m
[32m+[m[32m            ("EUR", "USD"),[m
[32m+[m[32m            ("GBP", "USD"),[m
[32m+[m[32m            ("USD", "JPY"),[m
[32m+[m[32m            ("USD", "CHF"),[m
[32m+[m[32m            ("AUD", "USD"),[m
[32m+[m[32m            ("USD", "CAD"),[m
[32m+[m[32m            ("NZD", "USD"),[m
[32m+[m[32m            ("EUR", "GBP"),[m
[32m+[m[32m            ("EUR", "JPY"),[m
[32m+[m[32m            ("GBP", "JPY"),[m
[32m+[m[32m        ][m
[32m+[m[41m    [m
[32m+[m[32m    def save_to_sql(self, df: pd.DataFrame, table: str) -> int:[m
[32m+[m[32m        """Save DataFrame to SQL with CSV backup."""[m
[32m+[m[32m        if df.empty:[m
[32m+[m[32m            return 0[m
[32m+[m[41m        [m
[32m+[m[32m        # CSV backup[m
[32m+[m[32m        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")[m
[32m+[m[32m        csv_path = self.backup_dir / f"{table}_{timestamp}.csv"[m
[32m+[m[32m        df.to_csv(csv_path, index=False)[m
[32m+[m[41m        [m
[32m+[m[32m        # SQL insert[m
[32m+[m[32m        try:[m
[32m+[m[32m            with self.engine.begin() as conn:[m
[32m+[m[32m                df.to_sql(table, conn, if_exists="append", index=False, chunksize=1000)[m
[32m+[m[32m            self.stats["rows_saved"] += len(df)[m
[32m+[m[32m            logger.info(f"Saved {len(df)} rows to {table}")[m
[32m+[m[32m            return len(df)[m
[32m+[m[32m        except Exception as e:[m
[32m+[m[32m            logger.error(f"SQL save failed (CSV backup at {csv_path}): {e}")[m
[32m+[m[32m            return 0[m
[32m+[m[41m    [m
[32m+[m[32m    def hydrate_stock_daily(self, symbol: str) -> bool:[m
[32m+[m[32m        """Hydrate daily stock data."""[m
[32m+[m[32m        try:[m
[32m+[m[32m            df = self.av.fetch_stock_daily(symbol, outputsize="full")[m
[32m+[m[32m            if not df.empty:[m
[32m+[m[32m                self.save_to_sql(df, "price_bars")[m
[32m+[m[32m                self.stats["stocks_daily"] += 1[m
[32m+[m[32m                return True[m
[32m+[m[32m        except Exception as e:[m
[32m+[m[32m            logger.error(f"Error fetching daily data for {symbol}: {e}")[m
[32m+[m[32m            self.stats["errors"] += 1[m
[32m+[m[32m        return False[m
[32m+[m[41m    [m
[32m+[m[32m    def hydrate_stock_intraday(self, symbol: str, interval: str = "5min") -> bool:[m
[32m+[m[32m        """Hydrate intraday stock data."""[m
[32m+[m[32m        try:[m
[32m+[m[32m            df = self.av.fetch_stock_intraday(symbol, interval=interval, outputsize="full")[m
[32m+[m[32m            if not df.empty:[m
[32m+[m[32m                self.save_to_sql(df, "price_bars")[m
[32m+[m[32m                self.stats["stocks_intraday"] += 1[m
[32m+[m[32m                return True[m
[32m+[m[32m        except Exception as e:[m
[32m+[m[32m            logger.error(f"Error fetching intraday data for {symbol}: {e}")[m
[32m+[m[32m            self.stats["errors"] += 1[m
[32m+[m[32m        return False[m
[32m+[m[41m    [m
[32m+[m[32m    def hydrate_fundamentals(self, symbol: str) -> bool:[m
[32m+[m[32m        """Hydrate fundamental data."""[m
[32m+[m[32m        try:[m
[32m+[m[32m            data = self.av.fetch_fundamental_data(symbol)[m
[32m+[m[32m            if data:[m
[32m+[m[32m                df = pd.DataFrame([data])[m
[32m+[m[32m                self.save_to_sql(df, "fundamentals")[m
[32m+[m[32m                self.stats["fundamentals"] += 1[m
[32m+[m[32m                return True[m
[32m+[m[32m        except Exception as e:[m
[32m+[m[32m            logger.error(f"Error fetching fundamentals for {symbol}: {e}")[m
[32m+[m[32m            self.stats["errors"] += 1[m
[32m+[m[32m        return False[m
[32m+[m[41m    [m
[32m+[m[32m    def hydrate_forex(self, from_currency: str, to_currency: str) -> bool:[m
[32m+[m[32m        """Hydrate forex pair data."""[m
[32m+[m[32m        try:[m
[32m+[m[32m            df = self.av.fetch_forex(from_currency, to_currency, interval="1min")[m
[32m+[m[32m            if not df.empty:[m
[32m+[m[32m                self.save_to_sql(df, "forex_bars")[m
[32m+[m[32m                self.stats["forex"] += 1[m
[32m+[m[32m                return True[m
[32m+[m[32m        except Exception as e:[m
[32m+[m[32m            logger.error(f"Error fetching forex {from_currency}/{to_currency}: {e}")[m
[32m+[m[32m            self.stats["errors"] += 1[m
[32m+[m[32m        return False[m
[32m+[m[41m    [m
[32m+[m[32m    def hydrate_stocks(self, symbols: List[str], include_intraday: bool = False):[m
[32m+[m[32m        """Hydrate all stock data."""[m
[32m+[m[32m        logger.info(f"\nHydrating {len(symbols)} stocks...")[m
[32m+[m[41m        [m
[32m+[m[32m        for i, symbol in enumerate(symbols):[m
[32m+[m[32m            logger.info(f"[{i+1}/{len(symbols)}] Processing {symbol}")[m
[32m+[m[41m            [m
[32m+[m[32m            # Daily data[m
[32m+[m[32m            self.hydrate_stock_daily(symbol)[m
[32m+[m[41m            [m
[32m+[m[32m            # Intraday (optional, uses more API calls)[m
[32m+[m[32m            if include_intraday:[m
[32m+[m[32m                self.hydrate_stock_intraday(symbol)[m
[32m+[m[41m            [m
[32m+[m[32m            # Fundamentals[m
[32m+[m[32m            self.hydrate_fundamentals(symbol)[m
[32m+[m[41m    [m
[32m+[m[32m    def hydrate_all_forex(self):[m
[32m+[m[32m        """Hydrate all forex pairs."""[m
[32m+[m[32m        pairs = self.get_forex_pairs()[m
[32m+[m[32m        logger.info(f"\nHydrating {len(pairs)} forex pairs...")[m
[32m+[m[41m        [m
[32m+[m[32m        for i, (from_curr, to_curr) in enumerate(pairs):[m
[32m+[m[32m            logger.info(f"[{i+1}/{len(pairs)}] Processing {from_curr}/{to_curr}")[m
[32m+[m[32m            self.hydrate_forex(from_curr, to_curr)[m
[32m+[m[41m    [m
[32m+[m[32m    def run_full_hydration([m
[32m+[m[32m        self,[m
[32m+[m[32m        stocks: bool = True,[m
[32m+[m[32m        fundamentals: bool = True,[m
[32m+[m[32m        forex: bool = True,[m
[32m+[m[32m        intraday: bool = False,[m
[32m+[m[32m        stock_limit: Optional[int] = None[m
[32m+[m[32m    ):[m
[32m+[m[32m        """Run full hydration."""[m
[32m+[m[32m        start_time = time.time()[m
[32m+[m[41m        [m
[32m+[m[32m        logger.info("\n" + "=" * 70)[m
[32m+[m[32m        logger.info("STARTING FULL HYDRATION")[m
[32m+[m[32m        logger.info("=" * 70)[m
[32m+[m[32m        logger.info(f"Stocks: {stocks}, Fundamentals: {fundamentals}, Forex: {forex}, Intraday: {intraday}")[m
[32m+[m[41m        [m
[32m+[m[32m        if stocks or fundamentals:[m
[32m+[m[32m            target_stocks = self.get_target_stocks(limit=stock_limit)[m
[32m+[m[32m            self.hydrate_stocks(target_stocks, include_intraday=intraday)[m
[32m+[m[41m        [m
[32m+[m[32m        if forex:[m
[32m+[m[32m            self.hydrate_all_forex()[m
[32m+[m[41m        [m
[32m+[m[32m        elapsed = time.time() - start_time[m
[32m+[m[41m        [m
[32m+[m[32m        logger.info("\n" + "=" * 70)[m
[32m+[m[32m        logger.info("HYDRATION COMPLETE")[m
[32m+[m[32m        logger.info("=" * 70)[m
[32m+[m[32m        logger.info(f"Time elapsed: {elapsed/60:.1f} minutes")[m
[32m+[m[32m        logger.info(f"Stocks daily: {self.stats['stocks_daily']}")[m
[32m+[m[32m        logger.info(f"Stocks intraday: {self.stats['stocks_intraday']}")[m
[32m+[m[32m        logger.info(f"Fundamentals: {self.stats['fundamentals']}")[m
[32m+[m[32m        logger.info(f"Forex pairs: {self.stats['forex']}")[m
[32m+[m[32m        logger.info(f"Total rows saved: {self.stats['rows_saved']}")[m
[32m+[m[32m        logger.info(f"Errors: {self.stats['errors']}")[m
[32m+[m[41m    [m
[32m+[m[32m    def run_quick_hydration(self):[m
[32m+[m[32m        """Quick hydration for testing."""[m
[32m+[m[32m        logger.info("Running quick hydration (10 stocks, no intraday)...")[m
[32m+[m[32m        self.run_full_hydration([m
[32m+[m[32m            stocks=True,[m
[32m+[m[32m            fundamentals=True,[m
[32m+[m[32m            forex=False,[m
[32m+[m[32m            intraday=False,[m
[32m+[m[32m            stock_limit=10[m
[32m+[m[32m        )[m
[32m+[m
[32m+[m
[32m+[m[32mdef main():[m
[32m+[m[32m    """Main entry point."""[m
[32m+[m[32m    parser = argparse.ArgumentParser([m
[32m+[m[32m        description="Alpha Vantage Data Hydration",[m
[32m+[m[32m        formatter_class=argparse.RawDescriptionHelpFormatter,[m
[32m+[m[32m        epilog="""[m
[32m+[m[32mExamples:[m
[32m+[m[32m    python scripts/hydrate_alpha_vantage.py              # Full hydration[m
[32m+[m[32m    python scripts/hydrate_alpha_vantage.py --quick      # Quick test[m
[32m+[m[32m    python scripts/hydrate_alpha_vantage.py --stocks-only[m
[32m+[m[32m    python scripts/hydrate_alpha_vantage.py --fundamentals-only[m
[32m+[m[32m    python scripts/hydrate_alpha_vantage.py --forex-only[m
[32m+[m[32m        """[m
[32m+[m[32m    )[m
[32m+[m[41m    [m
[32m+[m[32m    parser.add_argument("--quick", action="store_true", help="Quick test (10 stocks)")[m
[32m+[m[32m    parser.add_argument("--stocks-only", action="store_true", help="Hydrate stocks only")[m
[32m+[m[32m    parser.add_argument("--fundamentals-only", action="store_true", help="Hydrate fundamentals only")[m
[32m+[m[32m    parser.add_argument("--forex-only", action="store_true", help="Hydrate forex only")[m
[32m+[m[32m    parser.add_argument("--with-intraday", action="store_true", help="Include intraday data")[m
[32m+[m[32m    parser.add_argument("--limit", type=int, default=None, help="Limit number of stocks")[m
[32m+[m[41m    [m
[32m+[m[32m    args = parser.parse_args()[m
[32m+[m[41m    [m
[32m+[m[32m    # Setup logging[m
[32m+[m[32m    settings = get_settings()[m
[32m+[m[32m    log_file = settings.logs_dir / "alpha_vantage_hydration.log"[m
[32m+[m[32m    logger.add(log_file, rotation="50 MB", level="INFO")[m
[32m+[m[41m    [m
[32m+[m[32m    try:[m
[32m+[m[32m        hydrator = AlphaVantageHydrator()[m
[32m+[m[41m        [m
[32m+[m[32m        if args.quick:[m
[32m+[m[32m            hydrator.run_quick_hydration()[m
[32m+[m[32m        elif args.stocks_only:[m
[32m+[m[32m            stocks = hydrator.get_target_stocks(limit=args.limit)[m
[32m+[m[32m            hydrator.hydrate_stocks(stocks, include_intraday=args.with_intraday)[m
[32m+[m[32m        elif args.fundamentals_only:[m
[32m+[m[32m            stocks = hydrator.get_target_stocks(limit=args.limit)[m
[32m+[m[32m            for s in stocks:[m
[32m+[m[32m                hydrator.hydrate_fundamentals(s)[m
[32m+[m[32m        elif args.forex_only:[m
[32m+[m[32m            hydrator.hydrate_all_forex()[m
[32m+[m[32m        else:[m
[32m+[m[32m            hydrator.run_full_hydration([m
[32m+[m[32m                stocks=True,[m
[32m+[m[32m                fundamentals=True,[m
[32m+[m[32m                forex=True,[m
[32m+[m[32m                intraday=args.with_intraday,[m
[32m+[m[32m                stock_limit=args.limit[m
[32m+[m[32m            )[m
[32m+[m[41m            [m
[32m+[m[32m    except ValueError as e:[m
[32m+[m[32m        logger.error(str(e))[m
[32m+[m[32m        sys.exit(1)[m
[32m+[m[32m    except KeyboardInterrupt:[m
[32m+[m[32m        logger.info("Hydration interrupted by user")[m
[32m+[m[32m        sys.exit(0)[m
[32m+[m
[32m+[m
[32m+[m[32mif __name__ == "__main__":[m
[32m+[m[32m    main()[m
[32m+[m
[1mdiff --git a/scripts/train_small_mid_cap.py b/scripts/train_small_mid_cap.py[m
[1mnew file mode 100644[m
[1mindex 00000000..27da973a[m
[1m--- /dev/null[m
[1m+++ b/scripts/train_small_mid_cap.py[m
[36m@@ -0,0 +1,495 @@[m
[32m+[m[32m"""[m
[32m+[m[32m================================================================================[m
[32m+[m[32mSMALL/MID CAP TRAINING SCRIPT[m
[32m+[m[32m================================================================================[m
[32m+[m[32mAuthor: Alpha Loop Capital, LLC[m
[32m+[m
[32m+[m[32mTrains specialized models for small/mid cap trading strategies:[m
[32m+[m[32m1. Retail Arbitrage - Exploits bad bid/ask, odd lots, retail flow[m
[32m+[m[32m2. Conversion/Reversal - Options arbitrage detection[m
[32m+[m[32m3. Mean Reversion - Fades overextended retail moves[m
[32m+[m
[32m+[m[32mTarget Universe: Stocks <$10B market cap with high retail activity[m
[32m+[m
[32m+[m[32mUsage:[m
[32m+[m[32m    python scripts/train_small_mid_cap.py [--continuous] [--symbols AAPL,SOFI,...][m
[32m+[m
[32m+[m[32mOptions:[m
[32m+[m[32m    --continuous    Run in continuous mode (retrain every hour)[m
[32m+[m[32m    --symbols       Specific symbols to train on (default: small/mid cap universe)[m
[32m+[m[32m    --options       Include options arbitrage training[m
[32m+[m[32m================================================================================[m
[32m+[m[32m"""[m
[32m+[m
[32m+[m[32mimport sys[m
[32m+[m[32mimport os[m
[32m+[m[32mimport argparse[m
[32m+[m[32mimport time[m
[32m+[m[32mfrom datetime import datetime, timedelta[m
[32m+[m[32mfrom typing import List, Dict, Optional[m
[32m+[m
[32m+[m[32m# Add project root to path[m
[32m+[m[32msys.path.insert(0, os.path.dirname(os.path.dirname(os.path.abspath(__file__))))[m
[32m+[m
[32m+[m[32mimport pandas as pd[m
[32m+[m[32mimport numpy as np[m
[32m+[m[32mfrom loguru import logger[m
[32m+[m
[32m+[m[32mfrom src.config.settings import get_settings[m
[32m+[m[32mfrom src.database.connection import get_engine[m
[32m+[m[32mfrom src.data_ingestion.universe import get_small_mid_cap_universe, MARKET_CAP_TIERS[m
[32m+[m
[32m+[m[32m# Feature engineering[m
[32m+[m[32mfrom src.ml.feature_engineering import add_technical_indicators, prepare_features[m
[32m+[m[32mfrom src.ml.retail_inefficiency_features import ([m
[32m+[m[32m    add_retail_inefficiency_features,[m
[32m+[m[32m    create_retail_arbitrage_target,[m
[32m+[m[32m    get_retail_inefficiency_feature_names[m
[32m+[m[32m)[m
[32m+[m[32mfrom src.ml.options_arbitrage_features import ([m
[32m+[m[32m    add_options_arbitrage_features,[m
[32m+[m[32m    scan_for_conversion_reversals,[m
[32m+[m[32m    get_options_arbitrage_feature_names[m
[32m+[m[32m)[m
[32m+[m
[32m+[m[32m# Models[m
[32m+[m[32mfrom src.ml.small_mid_cap_models import ([m
[32m+[m[32m    RetailArbitrageModel,[m
[32m+[m[32m    ConversionReversalModel,[m
[32m+[m[32m    MeanReversionModel,[m
[32m+[m[32m    train_all_small_mid_cap_models,[m
[32m+[m[32m    ModelMetrics[m
[32m+[m[32m)[m
[32m+[m
[32m+[m
[32m+[m[32m# Small/Mid Cap Universe - High Retail Activity Stocks[m
[32m+[m[32mSMALL_MID_CAP_UNIVERSE = [[m
[32m+[m[32m    # Meme / High Retail Stocks[m
[32m+[m[32m    "GME", "AMC", "BBBY", "KOSS", "BB",[m
[32m+[m
[32m+[m[32m    # Fintech (Retail Favorites)[m
[32m+[m[32m    "SOFI", "HOOD", "AFRM", "UPST", "LC", "COIN",[m
[32m+[m
[32m+[m[32m    # EV / Clean Energy (Retail Heavy)[m
[32m+[m[32m    "RIVN", "LCID", "FSR", "NIO", "XPEV", "GOEV",[m
[32m+[m[32m    "PLUG", "FCEL", "BE", "BLNK", "CHPT",[m
[32m+[m
[32m+[m[32m    # Tech Small/Mid[m
[32m+[m[32m    "PLTR", "PATH", "IONQ", "RKLB", "JOBY", "LILM",[m
[32m+[m[32m    "S", "DOCN", "GTLB", "CFLT", "ESTC",[m
[32m+[m
[32m+[m[32m    # Biotech Small Cap[m
[32m+[m[32m    "RXRX", "DNA", "BEAM", "CRSP", "NTLA", "VERV",[m
[32m+[m[32m    "EDIT", "FATE", "BLUE", "SGEN",[m
[32m+[m
[32m+[m[32m    # Uranium / Nuclear[m
[32m+[m[32m    "UEC", "DNN", "NXE", "UUUU", "SMR", "LEU", "CCJ",[m
[32m+[m
[32m+[m[32m    # Cannabis[m
[32m+[m[32m    "TLRY", "CGC", "ACB", "CRON", "HEXO",[m
[32m+[m
[32m+[m[32m    # SPACs / De-SPACs[m
[32m+[m[32m    "OPEN", "RDFN", "WISH", "CLOV", "BARK",[m
[32m+[m
[32m+[m[32m    # Social / Gaming[m
[32m+[m[32m    "RBLX", "DKNG", "PENN", "U", "SNAP",[m
[32m+[m[32m][m
[32m+[m
[32m+[m
[32m+[m[32mdef load_price_data([m
[32m+[m[32m    symbols: List[str],[m
[32m+[m[32m    lookback_days: int = 90,[m
[32m+[m[32m    timeframe: str = "5min"[m
[32m+[m[32m) -> pd.DataFrame:[m
[32m+[m[32m    """[m
[32m+[m[32m    Load price data from database for training.[m
[32m+[m
[32m+[m[32m    Args:[m
[32m+[m[32m        symbols: List of symbols to load[m
[32m+[m[32m        lookback_days: Days of history to load[m
[32m+[m[32m        timeframe: Data granularity (not used for SQL, just for logging)[m
[32m+[m
[32m+[m[32m    Returns:[m
[32m+[m[32m        DataFrame with OHLCV data[m
[32m+[m[32m    """[m
[32m+[m[32m    from sqlalchemy import text[m
[32m+[m
[32m+[m[32m    engine = get_engine()[m
[32m+[m[32m    settings = get_settings()[m
[32m+[m
[32m+[m[32m    start_date = datetime.now() - timedelta(days=lookback_days)[m
[32m+[m[32m    start_date_str = start_date.strftime("%Y-%m-%d %H:%M:%S")[m
[32m+[m
[32m+[m[32m    all_data = [][m
[32m+[m
[32m+[m[32m    for symbol in symbols:[m
[32m+[m[32m        try:[m
[32m+[m[32m            # Use raw SQL with string formatting for SQL Server compatibility[m
[32m+[m[32m            query = f"""[m
[32m+[m[32m            SELECT symbol, timestamp, [open], high, low, [close], volume[m
[32m+[m[32m            FROM price_bars[m
[32m+[m[32m            WHERE symbol = '{symbol}'[m
[32m+[m[32m            AND timestamp >= '{start_date_str}'[m
[32m+[m[32m            ORDER BY timestamp[m
[32m+[m[32m            """[m
[32m+[m
[32m+[m[32m            df = pd.read_sql(query, engine)[m
[32m+[m
[32m+[m[32m            if len(df) > 100:  # Minimum data requirement[m
[32m+[m[32m                all_data.append(df)[m
[32m+[m[32m                logger.info(f"  Loaded {len(df)} bars for {symbol}")[m
[32m+[m[32m            else:[m
[32m+[m[32m                logger.warning(f"  Insufficient data for {symbol}: {len(df)} bars")[m
[32m+[m
[32m+[m[32m        except Exception as e:[m
[32m+[m[32m            logger.error(f"  Error loading {symbol}: {e}")[m
[32m+[m[32m            continue[m
[32m+[m
[32m+[m[32m    if not all_data:[m
[32m+[m[32m        logger.error("No data loaded!")[m
[32m+[m[32m        return pd.DataFrame()[m
[32m+[m
[32m+[m[32m    combined = pd.concat(all_data, ignore_index=True)[m
[32m+[m[32m    logger.info(f"Total data loaded: {len(combined)} bars across {len(all_data)} symbols")[m
[32m+[m
[32m+[m[32m    return combined[m
[32m+[m
[32m+[m
[32m+[m[32mdef load_options_data(symbols: List[str]) -> pd.DataFrame:[m
[32m+[m[32m    """[m
[32m+[m[32m    Load options chain data from database.[m
[32m+[m
[32m+[m[32m    Args:[m
[32m+[m[32m        symbols: List of underlying symbols[m
[32m+[m
[32m+[m[32m    Returns:[m
[32m+[m[32m        DataFrame with options data[m
[32m+[m[32m    """[m
[32m+[m[32m    engine = get_engine()[m
[32m+[m
[32m+[m[32m    try:[m
[32m+[m[32m        query = """[m
[32m+[m[32m        SELECT *[m
[32m+[m[32m        FROM options_contracts[m
[32m+[m[32m        WHERE underlying_symbol IN :symbols[m
[32m+[m[32m        AND expiry > GETDATE()[m
[32m+[m[32m        """[m
[32m+[m
[32m+[m[32m        # SQLAlchemy doesn't directly support IN with list, need to format[m
[32m+[m[32m        symbols_str = ", ".join([f"'{s}'" for s in symbols])[m
[32m+[m[32m        query = f"""[m
[32m+[m[32m        SELECT *[m
[32m+[m[32m        FROM options_contracts[m
[32m+[m[32m        WHERE underlying_symbol IN ({symbols_str})[m
[32m+[m[32m        """[m
[32m+[m
[32m+[m[32m        df = pd.read_sql(query, engine)[m
[32m+[m[32m        logger.info(f"Loaded {len(df)} options contracts")[m
[32m+[m[32m        return df[m
[32m+[m
[32m+[m[32m    except Exception as e:[m
[32m+[m[32m        logger.warning(f"Could not load options data: {e}")[m
[32m+[m[32m        return pd.DataFrame()[m
[32m+[m
[32m+[m
[32m+[m[32mdef train_retail_arbitrage_model([m
[32m+[m[32m    price_data: pd.DataFrame,[m
[32m+[m[32m    model_id: str = "v1"[m
[32m+[m[32m) -> Optional[ModelMetrics]:[m
[32m+[m[32m    """[m
[32m+[m[32m    Train the retail arbitrage model.[m
[32m+[m
[32m+[m[32m    Args:[m
[32m+[m[32m        price_data: OHLCV data[m
[32m+[m[32m        model_id: Model version identifier[m
[32m+[m
[32m+[m[32m    Returns:[m
[32m+[m[32m        ModelMetrics or None if training failed[m
[32m+[m[32m    """[m
[32m+[m[32m    logger.info("=" * 60)[m
[32m+[m[32m    logger.info("TRAINING RETAIL ARBITRAGE MODEL")[m
[32m+[m[32m    logger.info("=" * 60)[m
[32m+[m
[32m+[m[32m    try:[m
[32m+[m[32m        # Add technical indicators[m
[32m+[m[32m        logger.info("Adding technical indicators...")[m
[32m+[m[32m        df = add_technical_indicators(price_data.copy())[m
[32m+[m
[32m+[m[32m        # Add retail inefficiency features[m
[32m+[m[32m        logger.info("Adding retail inefficiency features...")[m
[32m+[m[32m        df = add_retail_inefficiency_features(df)[m
[32m+[m
[32m+[m[32m        # Create target[m
[32m+[m[32m        logger.info("Creating training target...")[m
[32m+[m[32m        df = create_retail_arbitrage_target(df, horizon=5, min_return=0.01)[m
[32m+[m
[32m+[m[32m        # Prepare features[m
[32m+[m[32m        exclude_cols = [[m
[32m+[m[32m            "symbol", "timestamp", "target", "target_long", "target_short",[m
[32m+[m[32m            "target_binary", "future_return", "open", "high", "low", "close",[m
[32m+[m[32m            "volume", "source", "asset_type"[m
[32m+[m[32m        ][m
[32m+[m[32m        feature_cols = [c for c in df.columns if c not in exclude_cols][m
[32m+[m
[32m+[m[32m        logger.info(f"Training with {len(feature_cols)} features on {len(df)} samples")[m
[32m+[m
[32m+[m[32m        X = df[feature_cols][m
[32m+[m[32m        y = df["target_binary"][m
[32m+[m
[32m+[m[32m        # Train model[m
[32m+[m[32m        model = RetailArbitrageModel(model_id)[m
[32m+[m[32m        metrics = model.train(X, y, cv_folds=5)[m
[32m+[m
[32m+[m[32m        # Save model[m
[32m+[m[32m        model.save()[m
[32m+[m
[32m+[m[32m        # Log feature importance[m
[32m+[m[32m        importance = model.get_feature_importance()[m
[32m+[m[32m        logger.info("Top 10 Features:")[m
[32m+[m[32m        for _, row in importance.head(10).iterrows():[m
[32m+[m[32m            logger.info(f"  {row['feature']}: {row['importance']:.4f}")[m
[32m+[m
[32m+[m[32m        logger.info(f"Retail Arbitrage Model trained: AUC={metrics.auc:.4f}, Acc={metrics.accuracy:.4f}")[m
[32m+[m
[32m+[m[32m        return metrics[m
[32m+[m
[32m+[m[32m    except Exception as e:[m
[32m+[m[32m        logger.error(f"Failed to train Retail Arbitrage Model: {e}")[m
[32m+[m[32m        import traceback[m
[32m+[m[32m        traceback.print_exc()[m
[32m+[m[32m        return None[m
[32m+[m
[32m+[m
[32m+[m[32mdef train_mean_reversion_model([m
[32m+[m[32m    price_data: pd.DataFrame,[m
[32m+[m[32m    model_id: str = "v1"[m
[32m+[m[32m) -> Optional[ModelMetrics]:[m
[32m+[m[32m    """[m
[32m+[m[32m    Train the mean reversion model.[m
[32m+[m
[32m+[m[32m    Targets overextended moves that are likely to revert.[m
[32m+[m[32m    """[m
[32m+[m[32m    logger.info("=" * 60)[m
[32m+[m[32m    logger.info("TRAINING MEAN REVERSION MODEL")[m
[32m+[m[32m    logger.info("=" * 60)[m
[32m+[m
[32m+[m[32m    try:[m
[32m+[m[32m        # Add features[m
[32m+[m[32m        df = add_technical_indicators(price_data.copy())[m
[32m+[m[32m        df = add_retail_inefficiency_features(df)[m
[32m+[m
[32m+[m[32m        # Target: price reverts after overextension[m
[32m+[m[32m        df["future_return"] = df["close"].pct_change(5).shift(-5)[m
[32m+[m
[32m+[m[32m        df["mean_rev_target"] = ([m
[32m+[m[32m            (abs(df["price_extension"]) > 2) &  # Overextended[m
[32m+[m[32m            # Price moves opposite to extension[m
[32m+[m[32m            (df["future_return"] * np.sign(df["price_extension"]) < 0)[m
[32m+[m[32m        ).astype(int)[m
[32m+[m
[32m+[m[32m        df.dropna(subset=["mean_rev_target", "future_return"], inplace=True)[m
[32m+[m
[32m+[m[32m        # Prepare features[m
[32m+[m[32m        exclude_cols = [[m
[32m+[m[32m            "symbol", "timestamp", "mean_rev_target", "future_return",[m
[32m+[m[32m            "open", "high", "low", "close", "volume"[m
[32m+[m[32m        ][m
[32m+[m[32m        feature_cols = [c for c in df.columns if c not in exclude_cols][m
[32m+[m
[32m+[m[32m        X = df[feature_cols][m
[32m+[m[32m        y = df["mean_rev_target"][m
[32m+[m
[32m+[m[32m        logger.info(f"Training with {len(feature_cols)} features on {len(df)} samples")[m
[32m+[m[32m        logger.info(f"Target distribution: {y.value_counts().to_dict()}")[m
[32m+[m
[32m+[m[32m        # Train[m
[32m+[m[32m        model = MeanReversionModel(model_id)[m
[32m+[m[32m        metrics = model.train(X, y, cv_folds=5)[m
[32m+[m[32m        model.save()[m
[32m+[m
[32m+[m[32m        logger.info(f"Mean Reversion Model trained: AUC={metrics.auc:.4f}, Acc={metrics.accuracy:.4f}")[m
[32m+[m[32m        return metrics[m
[32m+[m
[32m+[m[32m    except Exception as e:[m
[32m+[m[32m        logger.error(f"Failed to train Mean Reversion Model: {e}")[m
[32m+[m[32m        import traceback[m
[32m+[m[32m        traceback.print_exc()[m
[32m+[m[32m        return None[m
[32m+[m
[32m+[m
[32m+[m[32mdef train_conversion_reversal_model([m
[32m+[m[32m    options_data: pd.DataFrame,[m
[32m+[m[32m    model_id: str = "v1"[m
[32m+[m[32m) -> Optional[ModelMetrics]:[m
[32m+[m[32m    """[m
[32m+[m[32m    Train the conversion/reversal arbitrage model.[m
[32m+[m[32m    """[m
[32m+[m[32m    logger.info("=" * 60)[m
[32m+[m[32m    logger.info("TRAINING CONVERSION/REVERSAL MODEL")[m
[32m+[m[32m    logger.info("=" * 60)[m
[32m+[m
[32m+[m[32m    if options_data is None or len(options_data) == 0:[m
[32m+[m[32m        logger.warning("No options data available for training")[m
[32m+[m[32m        return None[m
[32m+[m
[32m+[m[32m    try:[m
[32m+[m[32m        # Add features[m
[32m+[m[32m        df = add_options_arbitrage_features(options_data.copy())[m
[32m+[m
[32m+[m[32m        # Target: arbitrage signal[m
[32m+[m[32m        df["arb_target"] = ([m
[32m+[m[32m            (df["conversion_signal"] == 1) |[m
[32m+[m[32m            (df["reversal_signal"] == 1)[m
[32m+[m[32m        ).astype(int)[m
[32m+[m
[32m+[m[32m        # Prepare features[m
[32m+[m[32m        exclude_cols = [[m
[32m+[m[32m            "symbol", "underlying_symbol", "underlying_price", "strike",[m
[32m+[m[32m            "expiry", "call_bid", "call_ask", "put_bid", "put_ask",[m
[32m+[m[32m            "arb_target", "T", "expiry_date"[m
[32m+[m[32m        ][m
[32m+[m[32m        feature_cols = [c for c in df.columns if c not in exclude_cols][m
[32m+[m
[32m+[m[32m        X = df[feature_cols][m
[32m+[m[32m        y = df["arb_target"][m
[32m+[m
[32m+[m[32m        logger.info(f"Training with {len(feature_cols)} features on {len(df)} samples")[m
[32m+[m
[32m+[m[32m        model = ConversionReversalModel(model_id)[m
[32m+[m[32m        metrics = model.train(X, y, cv_folds=3)[m
[32m+[m[32m        model.save()[m
[32m+[m
[32m+[m[32m        logger.info(f"Conversion/Reversal Model trained: AUC={metrics.auc:.4f}")[m
[32m+[m[32m        return metrics[m
[32m+[m
[32m+[m[32m    except Exception as e:[m
[32m+[m[32m        logger.error(f"Failed to train Conversion/Reversal Model: {e}")[m
[32m+[m[32m        import traceback[m
[32m+[m[32m        traceback.print_exc()[m
[32m+[m[32m        return None[m
[32m+[m
[32m+[m
[32m+[m[32mdef run_training_cycle([m
[32m+[m[32m    symbols: List[str],[m
[32m+[m[32m    include_options: bool = True[m
[32m+[m[32m) -> Dict[str, ModelMetrics]:[m
[32m+[m[32m    """[m
[32m+[m[32m    Run a complete training cycle for all small/mid cap models.[m
[32m+[m
[32m+[m[32m    Args:[m
[32m+[m[32m        symbols: List of symbols to train on[m
[32m+[m[32m        include_options: Whether to train options models[m
[32m+[m
[32m+[m[32m    Returns:[m
[32m+[m[32m        Dict of model_name -> metrics[m
[32m+[m[32m    """[m
[32m+[m[32m    logger.info("=" * 70)[m
[32m+[m[32m    logger.info("SMALL/MID CAP TRAINING CYCLE")[m
[32m+[m[32m    logger.info(f"Symbols: {len(symbols)}")[m
[32m+[m[32m    logger.info(f"Time: {datetime.now().isoformat()}")[m
[32m+[m[32m    logger.info("=" * 70)[m
[32m+[m
[32m+[m[32m    results = {}[m
[32m+[m
[32m+[m[32m    # Load price data[m
[32m+[m[32m    logger.info("\nLoading price data...")[m
[32m+[m[32m    price_data = load_price_data(symbols, lookback_days=90)[m
[32m+[m
[32m+[m[32m    if len(price_data) == 0:[m
[32m+[m[32m        logger.error("No price data loaded. Aborting training.")[m
[32m+[m[32m        return results[m
[32m+[m
[32m+[m[32m    # Train retail arbitrage model[m
[32m+[m[32m    retail_metrics = train_retail_arbitrage_model(price_data, model_id="v1")[m
[32m+[m[32m    if retail_metrics:[m
[32m+[m[32m        results["retail_arbitrage"] = retail_metrics[m
[32m+[m
[32m+[m[32m    # Train mean reversion model[m
[32m+[m[32m    mean_rev_metrics = train_mean_reversion_model(price_data, model_id="v1")[m
[32m+[m[32m    if mean_rev_metrics:[m
[32m+[m[32m        results["mean_reversion"] = mean_rev_metrics[m
[32m+[m
[32m+[m[32m    # Train options models (if enabled)[m
[32m+[m[32m    if include_options:[m
[32m+[m[32m        logger.info("\nLoading options data...")[m
[32m+[m[32m        options_data = load_options_data(symbols)[m
[32m+[m
[32m+[m[32m        if len(options_data) > 0:[m
[32m+[m[32m            conv_rev_metrics = train_conversion_reversal_model(options_data, model_id="v1")[m
[32m+[m[32m            if conv_rev_metrics:[m
[32m+[m[32m                results["conversion_reversal"] = conv_rev_metrics[m
[32m+[m
[32m+[m[32m    # Summary[m
[32m+[m[32m    logger.info("\n" + "=" * 70)[m
[32m+[m[32m    logger.info("TRAINING SUMMARY")[m
[32m+[m[32m    logger.info("=" * 70)[m
[32m+[m
[32m+[m[32m    for model_name, metrics in results.items():[m
[32m+[m[32m        passed = "PASS" if metrics.passes_threshold() else "FAIL"[m
[32m+[m[32m        logger.info([m
[32m+[m[32m            f"  {model_name}: AUC={metrics.auc:.4f}, "[m
[32m+[m[32m            f"Acc={metrics.accuracy:.4f}, F1={metrics.f1:.4f} [{passed}]"[m
[32m+[m[32m        )[m
[32m+[m
[32m+[m[32m    logger.info("=" * 70)[m
[32m+[m
[32m+[m[32m    return results[m
[32m+[m
[32m+[m
[32m+[m[32mdef main():[m
[32m+[m[32m    """Main entry point."""[m
[32m+[m[32m    parser = argparse.ArgumentParser(description="Train Small/Mid Cap Models")[m
[32m+[m[32m    parser.add_argument("--continuous", action="store_true", help="Run continuously")[m
[32m+[m[32m    parser.add_argument("--symbols", type=str, help="Comma-separated symbols")[m
[32m+[m[32m    parser.add_argument("--options", action="store_true", help="Include options training")[m
[32m+[m[32m    parser.add_argument("--interval", type=int, default=3600, help="Training interval (seconds)")[m
[32m+[m
[32m+[m[32m    args = parser.parse_args()[m
[32m+[m
[32m+[m[32m    # Setup logging[m
[32m+[m[32m    logger.add([m
[32m+[m[32m        "logs/small_mid_cap_training_{time}.log",[m
[32m+[m[32m        rotation="1 day",[m
[32m+[m[32m        retention="7 days",[m
[32m+[m[32m        level="INFO"[m
[32m+[m[32m    )[m
[32m+[m
[32m+[m[32m    # Determine symbols[m
[32m+[m[32m    if args.symbols:[m
[32m+[m[32m        symbols = [s.strip().upper() for s in args.symbols.split(",")][m
[32m+[m[32m    else:[m
[32m+[m[32m        symbols = SMALL_MID_CAP_UNIVERSE[m
[32m+[m
[32m+[m[32m    logger.info(f"Training on {len(symbols)} symbols")[m
[32m+[m
[32m+[m[32m    if args.continuous:[m
[32m+[m[32m        logger.info(f"Running in continuous mode (interval: {args.interval}s)")[m
[32m+[m
[32m+[m[32m        while True:[m
[32m+[m[32m            try:[m
[32m+[m[32m                run_training_cycle(symbols, include_options=args.options)[m
[32m+[m[32m                logger.info(f"Next training in {args.interval} seconds...")[m
[32m+[m[32m                time.sleep(args.interval)[m
[32m+[m[32m            except KeyboardInterrupt:[m
[32m+[m[32m                logger.info("Training interrupted by user")[m
[32m+[m[32m                break[m
[32m+[m[32m            except Exception as e:[m
[32m+[m[32m                logger.error(f"Training cycle failed: {e}")[m
[32m+[m[32m                logger.info("Retrying in 60 seconds...")[m
[32m+[m[32m                time.sleep(60)[m
[32m+[m[32m    else:[m
[32m+[m[32m        # Single training run[m
[32m+[m[32m        results = run_training_cycle(symbols, include_options=args.options)[m
[32m+[m
[32m+[m[32m        # Exit code based on results[m
[32m+[m[32m        if results:[m
[32m+[m[32m            passing = sum(1 for m in results.values() if m.passes_threshold())[m
[32m+[m[32m            logger.info(f"\n{passing}/{len(results)} models passed thresholds")[m
[32m+[m[32m            sys.exit(0 if passing > 0 else 1)[m
[32m+[m[32m        else:[m
[32m+[m[32m            logger.error("No models trained successfully")[m
[32m+[m[32m            sys.exit(1)[m
[32m+[m
[32m+[m
[32m+[m[32mif __name__ == "__main__":[m
[32m+[m[32m    main()[m
[1mdiff --git a/src/agents/nobus_agent/nobus_agent.py b/src/agents/nobus_agent/nobus_agent.py[m
[1mindex c6c86c8f..17d90b24 100644[m
[1m--- a/src/agents/nobus_agent/nobus_agent.py[m
[1m+++ b/src/agents/nobus_agent/nobus_agent.py[m
[36m@@ -1,25 +1,1064 @@[m
[32m+[m[32m"""[m
[32m+[m[32m================================================================================[m
[32m+[m[32mNOBUS AGENT - "Nobody But Us" - Proprietary Intelligence Operations[m
[32m+[m[32m================================================================================[m
[32m+[m[32mAuthor: Tom Hogan | Alpha Loop Capital, LLC[m
[32m+[m
[32m+[m[32mNOBUS (Nobody But Us) is an NSA term for vulnerabilities that only the NSA[m
[32m+[m[32mcan exploit because of their unique capabilities.[m
[32m+[m
[32m+[m[32mIn trading context: NOBUS signals are information advantages that require[m
[32m+[m[32munique infrastructure, thinking, or access to detect.[m
[32m+[m
[32m+[m[32mPHILOSOPHY:[m
[32m+[m[32m- If everyone can see it, it's not edge[m
[32m+[m[32m- Proprietary signals come from proprietary thinking[m
[32m+[m[32m- The best signals are the ones no one else is looking for[m
[32m+[m[32m- Intelligence operations, not research operations[m
[32m+[m
[32m+[m[32mThis agent manages:[m
[32m+[m[32m1. FAULT INJECTION - Stress testing our own systems[m
[32m+[m[32m2. EDGE DECAY MONITORING - How fast is our alpha eroding?[m
[32m+[m[32m3. CROWDING DETECTION - Are others trading our signals?[m
[32m+[m[32m4. SIGNAL UNIQUENESS SCORING - How proprietary is each signal?[m
[32m+[m[32m5. INFORMATION LEAKAGE DETECTION - Are we leaving footprints?[m
[32m+[m[32m6. ADVERSARIAL THINKING - What would Goldman/Citadel do?[m
[32m+[m
[32m+[m[32mReports To: ORCHESTRATOR[m
[32m+[m[32mTier: SUPPORT (Operates in the shadows)[m
[32m+[m
[32m+[m[32mCore Philosophy:[m
[32m+[m[32m"In the intelligence business, we would say that's the golden gift that keeps on[m
[32m+[m[32mgiving when you have the information your adversary doesn't know you have."[m
[32m+[m[32m- Gen. Michael Hayden[m
[32m+[m[32m================================================================================[m
[32m+[m[32m"""[m
[32m+[m
[32m+[m[32mimport logging[m
[32m+[m[32mfrom datetime import datetime, timedelta[m
[32m+[m[32mfrom typing import Dict, List, Optional, Any, Tuple[m
[32m+[m[32mfrom dataclasses import dataclass, field[m
[32m+[m[32mfrom enum import Enum[m
[32m+[m[32mimport hashlib[m
[32m+[m[32mimport random[m
 [m
[31m-"""NOBUSAgent - resilience and fault injection."""[m
[31m-from typing import Any, Dict, List[m
 from src.core.agent_base import BaseAgent, AgentTier[m
 [m
[32m+[m[32mlogger = logging.getLogger(__name__)[m
[32m+[m
[32m+[m
[32m+[m[32mclass EdgeDecayRate(Enum):[m
[32m+[m[32m    """How fast is our edge decaying?"""[m
[32m+[m[32m    PERMANENT = "permanent"     # Structural advantage, won't decay[m
[32m+[m[32m    SLOW = "slow"              # Years to decay (rare)[m
[32m+[m[32m    MODERATE = "moderate"      # Months to decay[m
[32m+[m[32m    FAST = "fast"              # Weeks to decay[m
[32m+[m[32m    CRITICAL = "critical"      # Days - act immediately or lose[m
[32m+[m
[32m+[m
[32m+[m[32mclass CrowdingLevel(Enum):[m
[32m+[m[32m    """How crowded is this trade/signal?"""[m
[32m+[m[32m    UNCROWDED = "uncrowded"     # We're alone[m
[32m+[m[32m    EARLY = "early"            # Few others, first mover[m
[32m+[m[32m    BUILDING = "building"      # Others catching on[m
[32m+[m[32m    CROWDED = "crowded"        # Consensus trade[m
[32m+[m[32m    EXTREMELY_CROWDED = "extremely_crowded"  # Exit risk[m
[32m+[m
[32m+[m
[32m+[m[32mclass AdversaryType(Enum):[m
[32m+[m[32m    """Types of market adversaries to model."""[m
[32m+[m[32m    CITADEL = "citadel"        # HFT, market making, stat arb[m
[32m+[m[32m    RENAISSANCE = "renaissance"  # Pure quant, pattern recognition[m
[32m+[m[32m    TWO_SIGMA = "two_sigma"    # Alt data, ML-heavy[m
[32m+[m[32m    BRIDGEWATER = "bridgewater"  # Macro, systematic[m
[32m+[m[32m    TIGER_GLOBAL = "tiger_global"  # Tech/growth fundamental[m
[32m+[m[32m    ACTIVIST = "activist"      # Concentrated, event-driven[m
[32m+[m[32m    RETAIL = "retail"          # Momentum, memes[m
[32m+[m
[32m+[m
[32m+[m[32m@dataclass[m
[32m+[m[32mclass EdgeSignal:[m
[32m+[m[32m    """A signal with edge decay tracking."""[m
[32m+[m[32m    signal_id: str[m
[32m+[m[32m    signal_name: str[m
[32m+[m[32m    signal_type: str[m
[32m+[m[41m    [m
[32m+[m[32m    # Edge metrics[m
[32m+[m[32m    edge_bps: float  # Alpha in basis points[m
[32m+[m[32m    decay_rate: EdgeDecayRate[m
[32m+[m[32m    discovery_date: datetime[m
[32m+[m[32m    expected_half_life_days: int  # When edge is 50% of original[m
[32m+[m[41m    [m
[32m+[m[32m    # Crowding[m
[32m+[m[32m    crowding_level: CrowdingLevel[m
[32m+[m[32m    estimated_capital_trading: float  # $ millions[m
[32m+[m[41m    [m
[32m+[m[32m    # Uniqueness[m
[32m+[m[32m    uniqueness_score: float  # 0-100, higher = more proprietary[m
[32m+[m[32m    replicability: str  # "easy", "hard", "impossible"[m
[32m+[m[32m    data_source_uniqueness: str[m
[32m+[m[41m    [m
[32m+[m[32m    # Adversary awareness[m
[32m+[m[32m    citadel_likely_knows: bool[m
[32m+[m[32m    renaissance_likely_knows: bool[m
[32m+[m[32m    two_sigma_likely_knows: bool[m
[32m+[m[41m    [m
[32m+[m[32m    def to_dict(self) -> Dict:[m
[32m+[m[32m        return {[m
[32m+[m[32m            "signal_id": self.signal_id,[m
[32m+[m[32m            "signal_name": self.signal_name,[m
[32m+[m[32m            "edge_bps": self.edge_bps,[m
[32m+[m[32m            "decay_rate": self.decay_rate.value,[m
[32m+[m[32m            "crowding": self.crowding_level.value,[m
[32m+[m[32m            "uniqueness_score": self.uniqueness_score,[m
[32m+[m[32m            "expected_half_life_days": self.expected_half_life_days,[m
[32m+[m[32m        }[m
[32m+[m
[32m+[m
[32m+[m[32m@dataclass[m
[32m+[m[32mclass FaultInjection:[m
[32m+[m[32m    """A fault injection test."""[m
[32m+[m[32m    fault_id: str[m
[32m+[m[32m    fault_type: str  # "latency", "data_corruption", "api_failure", "extreme_vol"[m
[32m+[m[32m    target_system: str[m
[32m+[m[32m    injected_at: datetime[m
[32m+[m[32m    duration_seconds: int[m
[32m+[m[32m    severity: str  # "minor", "moderate", "severe", "catastrophic"[m
[32m+[m[41m    [m
[32m+[m[32m    # Results[m
[32m+[m[32m    system_response: str[m
[32m+[m[32m    recovery_time_seconds: float[m
[32m+[m[32m    data_loss: bool[m
[32m+[m[32m    positions_affected: int[m
[32m+[m[32m    passed: bool[m
[32m+[m[41m    [m
[32m+[m[32m    def to_dict(self) -> Dict:[m
[32m+[m[32m        return {[m
[32m+[m[32m            "fault_id": self.fault_id,[m
[32m+[m[32m            "type": self.fault_type,[m
[32m+[m[32m            "target": self.target_system,[m
[32m+[m[32m            "severity": self.severity,[m
[32m+[m[32m            "passed": self.passed,[m
[32m+[m[32m            "recovery_time_s": self.recovery_time_seconds,[m
[32m+[m[32m        }[m
[32m+[m
[32m+[m
[32m+[m[32m@dataclass[m
[32m+[m[32mclass AdversaryModel:[m
[32m+[m[32m    """Model of an adversary's capabilities and likely behavior."""[m
[32m+[m[32m    adversary: AdversaryType[m
[32m+[m[41m    [m
[32m+[m[32m    # Capabilities[m
[32m+[m[32m    data_advantage: List[str]  # What data do they have we don't?[m
[32m+[m[32m    compute_advantage: float  # Multiplier vs us[m
[32m+[m[32m    latency_advantage_ms: float  # How much faster are they?[m
[32m+[m[32m    capital_base: float  # $ billions AUM[m
[32m+[m[41m    [m
[32m+[m[32m    # Strategies[m
[32m+[m[32m    likely_strategies: List[str][m
[32m+[m[32m    market_focus: List[str][m
[32m+[m[32m    time_horizon: str[m
[32m+[m[41m    [m
[32m+[m[32m    # Intelligence[m
[32m+[m[32m    signals_they_probably_trade: List[str][m
[32m+[m[32m    overlap_with_our_signals: float  # 0-1[m
[32m+[m[41m    [m
[32m+[m[32m    def to_dict(self) -> Dict:[m
[32m+[m[32m        return {[m
[32m+[m[32m            "adversary": self.adversary.value,[m
[32m+[m[32m            "data_advantage": self.data_advantage,[m
[32m+[m[32m            "compute_advantage": self.compute_advantage,[m
[32m+[m[32m            "capital_billions": self.capital_base,[m
[32m+[m[32m            "signal_overlap": self.overlap_with_our_signals,[m
[32m+[m[32m        }[m
[32m+[m
 [m
 class NOBUSAgent(BaseAgent):[m
[32m+[m[32m    """[m
[32m+[m[32m    NOBUS Agent - Proprietary Intelligence Operations[m
[32m+[m[41m    [m
[32m+[m[32m    This agent ensures our signals remain proprietary and our systems[m
[32m+[m[32m    remain resilient. It thinks like an adversary to stay ahead.[m
[32m+[m[41m    [m
[32m+[m[32m    Core Functions:[m
[32m+[m[32m    - inject_fault(): Stress test our systems[m
[32m+[m[32m    - measure_edge_decay(): Track alpha erosion[m
[32m+[m[32m    - detect_crowding(): Monitor for crowded trades[m
[32m+[m[32m    - score_uniqueness(): Rate signal proprietary-ness[m
[32m+[m[32m    - model_adversary(): Think like Goldman/Citadel[m
[32m+[m[32m    - detect_information_leakage(): Are we leaving footprints?[m
[32m+[m[41m    [m
[32m+[m[32m    Key Principles:[m
[32m+[m[32m    1. Assume adversaries are smarter than us[m
[32m+[m[32m    2. Assume all signals decay - the question is how fast[m
[32m+[m[32m    3. Assume we're being front-run until proven otherwise[m
[32m+[m[32m    4. Test for catastrophic failures, not just normal operation[m
[32m+[m[32m    5. Paranoia is a feature, not a bug[m
[32m+[m[32m    """[m
[32m+[m[41m    [m
[32m+[m[32m    # Adversary models[m
[32m+[m[32m    ADVERSARY_PROFILES = {[m
[32m+[m[32m        AdversaryType.CITADEL: AdversaryModel([m
[32m+[m[32m            adversary=AdversaryType.CITADEL,[m
[32m+[m[32m            data_advantage=["order_flow", "market_making_intel", "hft_signals"],[m
[32m+[m[32m            compute_advantage=100.0,  # 100x our compute[m
[32m+[m[32m            latency_advantage_ms=1.0,  # 1ms faster[m
[32m+[m[32m            capital_base=55.0,  # $55B[m
[32m+[m[32m            likely_strategies=["market_making", "stat_arb", "momentum", "event_arb"],[m
[32m+[m[32m            market_focus=["equities", "options", "etfs", "fx"],[m
[32m+[m[32m            time_horizon="intraday_to_weeks",[m
[32m+[m[32m            signals_they_probably_trade=["momentum", "mean_reversion", "flow", "vol"],[m
[32m+[m[32m            overlap_with_our_signals=0.3,  # 30% overlap[m
[32m+[m[32m        ),[m
[32m+[m[32m        AdversaryType.RENAISSANCE: AdversaryModel([m
[32m+[m[32m            adversary=AdversaryType.RENAISSANCE,[m
[32m+[m[32m            data_advantage=["decades_of_data", "proprietary_features", "physics_phds"],[m
[32m+[m[32m            compute_advantage=50.0,[m
[32m+[m[32m            latency_advantage_ms=0.5,[m
[32m+[m[32m            capital_base=130.0,  # Medallion ~$130B[m
[32m+[m[32m            likely_strategies=["pattern_recognition", "mean_reversion", "stat_arb"],[m
[32m+[m[32m            market_focus=["everything_liquid"],[m
[32m+[m[32m            time_horizon="seconds_to_days",[m
[32m+[m[32m            signals_they_probably_trade=["every_known_anomaly"],[m
[32m+[m[32m            overlap_with_our_signals=0.5,  # 50% overlap on known signals[m
[32m+[m[32m        ),[m
[32m+[m[32m        AdversaryType.TWO_SIGMA: AdversaryModel([m
[32m+[m[32m            adversary=AdversaryType.TWO_SIGMA,[m
[32m+[m[32m            data_advantage=["satellite", "credit_card", "social_media", "geolocation"],[m
[32m+[m[32m            compute_advantage=30.0,[m
[32m+[m[32m            latency_advantage_ms=5.0,[m
[32m+[m[32m            capital_base=60.0,[m
[32m+[m[32m            likely_strategies=["alt_data_alpha", "ml_strategies", "macro"],[m
[32m+[m[32m            market_focus=["equities", "macro", "credit"],[m
[32m+[m[32m            time_horizon="days_to_months",[m
[32m+[m[32m            signals_they_probably_trade=["alt_data", "nlp_sentiment", "factor_timing"],[m
[32m+[m[32m            overlap_with_our_signals=0.4,[m
[32m+[m[32m        ),[m
[32m+[m[32m        AdversaryType.BRIDGEWATER: AdversaryModel([m
[32m+[m[32m            adversary=AdversaryType.BRIDGEWATER,[m
[32m+[m[32m            data_advantage=["macro_research", "central_bank_intel"],[m
[32m+[m[32m            compute_advantage=10.0,[m
[32m+[m[32m            latency_advantage_ms=100.0,  # Don't care about latency[m
[32m+[m[32m            capital_base=150.0,[m
[32m+[m[32m            likely_strategies=["risk_parity", "macro", "systematic"],[m
[32m+[m[32m            market_focus=["bonds", "fx", "commodities", "equities"],[m
[32m+[m[32m            time_horizon="months_to_years",[m
[32m+[m[32m            signals_they_probably_trade=["macro_regimes", "risk_premiums"],[m
[32m+[m[32m            overlap_with_our_signals=0.2,[m
[32m+[m[32m        ),[m
[32m+[m[32m    }[m
[32m+[m[41m    [m
     def __init__(self, user_id: str = "TJH"):[m
         super().__init__([m
             name="NOBUSAgent",[m
             tier=AgentTier.SUPPORT,[m
[31m-            capabilities=["fault_injection", "stress_test"],[m
[32m+[m[32m            capabilities=[[m
[32m+[m[32m                # Fault injection[m
[32m+[m[32m                "fault_injection",[m
[32m+[m[32m                "stress_testing",[m
[32m+[m[32m                "chaos_engineering",[m
[32m+[m[32m                "recovery_testing",[m
[32m+[m[32m                "data_corruption_simulation",[m
[32m+[m[41m                [m
[32m+[m[32m                # Edge decay[m
[32m+[m[32m                "edge_decay_monitoring",[m
[32m+[m[32m                "alpha_erosion_tracking",[m
[32m+[m[32m                "half_life_estimation",[m
[32m+[m[32m                "signal_shelf_life",[m
[32m+[m[41m                [m
[32m+[m[32m                # Crowding detection[m
[32m+[m[32m                "crowding_detection",[m
[32m+[m[32m                "capital_flow_estimation",[m
[32m+[m[32m                "consensus_trade_detection",[m
[32m+[m[32m                "exit_risk_assessment",[m
[32m+[m[41m                [m
[32m+[m[32m                # Uniqueness scoring[m
[32m+[m[32m                "signal_uniqueness_scoring",[m
[32m+[m[32m                "replicability_assessment",[m
[32m+[m[32m                "data_source_uniqueness",[m
[32m+[m[32m                "methodology_uniqueness",[m
[32m+[m[41m                [m
[32m+[m[32m                # Adversary modeling[m
[32m+[m[32m                "adversary_modeling",[m
[32m+[m[32m                "capability_assessment",[m
[32m+[m[32m                "strategy_prediction",[m
[32m+[m[32m                "front_running_detection",[m
[32m+[m[41m                [m
[32m+[m[32m                # Information security[m
[32m+[m[32m                "information_leakage_detection",[m
[32m+[m[32m                "footprint_analysis",[m
[32m+[m[32m                "execution_anonymization",[m
[32m+[m[32m                "signal_obfuscation",[m
[32m+[m[32m            ],[m
             user_id=user_id,[m
         )[m
[31m-[m
[32m+[m[41m        [m
[32m+[m[32m        # Signal tracking[m
[32m+[m[32m        self.edge_signals: List[EdgeSignal] = [][m
[32m+[m[32m        self.fault_history: List[FaultInjection] = [][m
[32m+[m[41m        [m
[32m+[m[32m        # Adversary models[m
[32m+[m[32m        self.adversary_models = self.ADVERSARY_PROFILES.copy()[m
[32m+[m[41m        [m
[32m+[m[32m        # Metrics[m
[32m+[m[32m        self.total_faults_injected = 0[m
[32m+[m[32m        self.faults_passed = 0[m
[32m+[m[32m        self.faults_failed = 0[m
[32m+[m[32m        self.edge_decay_alerts = 0[m
[32m+[m[32m        self.crowding_alerts = 0[m
[32m+[m[41m        [m
[32m+[m[32m        self.logger.info("NOBUSAgent initialized - Operating in the shadows")[m
[32m+[m[41m    [m
     def process(self, task: Dict[str, Any]) -> Dict[str, Any]:[m
[31m-        return {[m
[31m-            "success": True,[m
[31m-            "agent": self.name,[m
[31m-            "task": task.get("type", "stress_test"),[m
[31m-            "note": "Simulated failure/edge-case applied",[m
[32m+[m[32m        """Process a NOBUS task."""[m
[32m+[m[32m        action = task.get("action", task.get("type", ""))[m
[32m+[m[32m        params = task.get("parameters", task)[m
[32m+[m[41m        [m
[32m+[m[32m        self.log_action(action, f"NOBUS processing: {action}")[m
[32m+[m[41m        [m
[32m+[m[32m        handlers = {[m
[32m+[m[32m            # Fault injection[m
[32m+[m[32m            "inject_fault": self._handle_inject_fault,[m
[32m+[m[32m            "stress_test": self._handle_stress_test,[m
[32m+[m[32m            "test_recovery": self._handle_test_recovery,[m
[32m+[m[41m            [m
[32m+[m[32m            # Edge decay[m
[32m+[m[32m            "measure_edge_decay": self._handle_edge_decay,[m
[32m+[m[32m            "estimate_half_life": self._handle_half_life,[m
[32m+[m[32m            "track_signal": self._handle_track_signal,[m
[32m+[m[41m            [m
[32m+[m[32m            # Crowding[m
[32m+[m[32m            "detect_crowding": self._handle_detect_crowding,[m
[32m+[m[32m            "estimate_capital": self._handle_estimate_capital,[m
[32m+[m[41m            [m
[32m+[m[32m            # Uniqueness[m
[32m+[m[32m            "score_uniqueness": self._handle_score_uniqueness,[m
[32m+[m[41m            [m
[32m+[m[32m            # Adversary[m
[32m+[m[32m            "model_adversary": self._handle_model_adversary,[m
[32m+[m[32m            "assess_adversary_overlap": self._handle_assess_overlap,[m
[32m+[m[41m            [m
[32m+[m[32m            # Info security[m
[32m+[m[32m            "detect_leakage": self._handle_detect_leakage,[m
[32m+[m[41m            [m
[32m+[m[32m            # Status[m
[32m+[m[32m            "status": self._handle_status,[m
         }[m
[31m-[m
[32m+[m[41m        [m
[32m+[m[32m        handler = handlers.get(action, self._handle_unknown)[m
[32m+[m[32m        return handler(params)[m
[32m+[m[41m    [m
     def get_capabilities(self) -> List[str]:[m
         return self.capabilities[m
[32m+[m[41m    [m
[32m+[m[32m    # =========================================================================[m
[32m+[m[32m    # FAULT INJECTION - "Break it before the market does"[m
[32m+[m[32m    # =========================================================================[m
[32m+[m[41m    [m
[32m+[m[32m    def inject_fault([m
[32m+[m[32m        self,[m
[32m+[m[32m        fault_type: str,[m
[32m+[m[32m        target_system: str,[m
[32m+[m[32m        severity: str = "moderate",[m
[32m+[m[32m        duration_seconds: int = 60[m
[32m+[m[32m    ) -> FaultInjection:[m
[32m+[m[32m        """[m
[32m+[m[32m        Inject a fault to test system resilience.[m
[32m+[m[41m        [m
[32m+[m[32m        FAULT TYPES:[m
[32m+[m[32m        - latency: Add artificial latency to APIs[m
[32m+[m[32m        - data_corruption: Introduce bad data[m
[32m+[m[32m        - api_failure: Simulate API outage[m
[32m+[m[32m        - extreme_vol: Simulate 4-sigma market move[m
[32m+[m[32m        - cascade_failure: Knock out multiple systems[m
[32m+[m[32m        - data_stale: Freeze data feeds[m
[32m+[m[41m        [m
[32m+[m[32m        PHILOSOPHY: If we don't break it, the market will.[m
[32m+[m[32m        Systems that aren't stress tested aren't production ready.[m
[32m+[m[32m        """[m
[32m+[m[32m        fault_id = f"fault_{hashlib.sha256(f'{fault_type}{target_system}{datetime.now()}'.encode()).hexdigest()[:8]}"[m
[32m+[m[41m        [m
[32m+[m[32m        # Simulate fault injection and system response[m
[32m+[m[32m        # In production, would actually inject faults[m
[32m+[m[41m        [m
[32m+[m[32m        # Simulate outcomes[m
[32m+[m[32m        if severity == "minor":[m
[32m+[m[32m            passed = random.random() > 0.1  # 90% pass rate for minor[m
[32m+[m[32m            recovery_time = random.uniform(0.5, 5.0)[m
[32m+[m[32m        elif severity == "moderate":[m
[32m+[m[32m            passed = random.random() > 0.2  # 80% pass rate[m
[32m+[m[32m            recovery_time = random.uniform(2.0, 30.0)[m
[32m+[m[32m        elif severity == "severe":[m
[32m+[m[32m            passed = random.random() > 0.4  # 60% pass rate[m
[32m+[m[32m            recovery_time = random.uniform(10.0, 120.0)[m
[32m+[m[32m        else:  # catastrophic[m
[32m+[m[32m            passed = random.random() > 0.6  # 40% pass rate[m
[32m+[m[32m            recovery_time = random.uniform(60.0, 600.0)[m
[32m+[m[41m        [m
[32m+[m[32m        fault = FaultInjection([m
[32m+[m[32m            fault_id=fault_id,[m
[32m+[m[32m            fault_type=fault_type,[m
[32m+[m[32m            target_system=target_system,[m
[32m+[m[32m            injected_at=datetime.now(),[m
[32m+[m[32m            duration_seconds=duration_seconds,[m
[32m+[m[32m            severity=severity,[m
[32m+[m[32m            system_response="recovered" if passed else "degraded",[m
[32m+[m[32m            recovery_time_seconds=recovery_time,[m
[32m+[m[32m            data_loss=not passed and random.random() > 0.5,[m
[32m+[m[32m            positions_affected=0 if passed else random.randint(1, 10),[m
[32m+[m[32m            passed=passed,[m
[32m+[m[32m        )[m
[32m+[m[41m        [m
[32m+[m[32m        self.fault_history.append(fault)[m
[32m+[m[32m        self.total_faults_injected += 1[m
[32m+[m[41m        [m
[32m+[m[32m        if passed:[m
[32m+[m[32m            self.faults_passed += 1[m
[32m+[m[32m        else:[m
[32m+[m[32m            self.faults_failed += 1[m
[32m+[m[32m            self.logger.warning(f"FAULT TEST FAILED: {fault_type} on {target_system}")[m
[32m+[m[41m        [m
[32m+[m[32m        return fault[m
[32m+[m[41m    [m
[32m+[m[32m    def run_chaos_engineering_suite(self) -> Dict[str, Any]:[m
[32m+[m[32m        """[m
[32m+[m[32m        Run comprehensive chaos engineering tests.[m
[32m+[m[41m        [m
[32m+[m[32m        Tests all critical systems with various fault types.[m
[32m+[m[32m        """[m
[32m+[m[32m        systems = [[m
[32m+[m[32m            "data_ingestion",[m
[32m+[m[32m            "signal_generation",[m
[32m+[m[32m            "portfolio_optimization",[m
[32m+[m[32m            "execution_engine",[m
[32m+[m[32m            "risk_management",[m
[32m+[m[32m            "database",[m
[32m+[m[32m            "api_gateway",[m
[32m+[m[32m        ][m
[32m+[m[41m        [m
[32m+[m[32m        fault_types = [[m
[32m+[m[32m            ("latency", "moderate"),[m
[32m+[m[32m            ("api_failure", "moderate"),[m
[32m+[m[32m            ("data_stale", "minor"),[m
[32m+[m[32m            ("extreme_vol", "severe"),[m
[32m+[m[32m        ][m
[32m+[m[41m        [m
[32m+[m[32m        results = [][m
[32m+[m[32m        for system in systems:[m
[32m+[m[32m            system_results = [][m
[32m+[m[32m            for fault_type, severity in fault_types:[m
[32m+[m[32m                fault = self.inject_fault(fault_type, system, severity, 30)[m
[32m+[m[32m                system_results.append(fault.to_dict())[m
[32m+[m[41m            [m
[32m+[m[32m            passed = sum(1 for r in system_results if r["passed"])[m
[32m+[m[32m            results.append({[m
[32m+[m[32m                "system": system,[m
[32m+[m[32m                "tests_run": len(fault_types),[m
[32m+[m[32m                "tests_passed": passed,[m
[32m+[m[32m                "pass_rate": passed / len(fault_types),[m
[32m+[m[32m            })[m
[32m+[m[41m        [m
[32m+[m[32m        overall_pass_rate = sum(r["pass_rate"] for r in results) / len(results)[m
[32m+[m[41m        [m
[32m+[m[32m        return {[m
[32m+[m[32m            "status": "completed",[m
[32m+[m[32m            "systems_tested": len(systems),[m
[32m+[m[32m            "fault_types_tested": len(fault_types),[m
[32m+[m[32m            "overall_pass_rate": overall_pass_rate,[m
[32m+[m[32m            "production_ready": overall_pass_rate > 0.8,[m
[32m+[m[32m            "results": results,[m
[32m+[m[32m        }[m
[32m+[m[41m    [m
[32m+[m[32m    # =========================================================================[m
[32m+[m[32m    # EDGE DECAY - "All alpha decays, the question is how fast"[m
[32m+[m[32m    # =========================================================================[m
[32m+[m[41m    [m
[32m+[m[32m    def measure_edge_decay([m
[32m+[m[32m        self,[m
[32m+[m[32m        signal_name: str,[m
[32m+[m[32m        historical_returns: List[float] = None,[m
[32m+[m[32m        months_since_discovery: int = 0[m
[32m+[m[32m    ) -> Dict[str, Any]:[m
[32m+[m[32m        """[m
[32m+[m[32m        Measure how fast a signal's edge is decaying.[m
[32m+[m[41m        [m
[32m+[m[32m        EDGE DECAY CAUSES:[m
[32m+[m[32m        - Crowding: More capital chasing same signal[m
[32m+[m[32m        - Publication: Academic papers reveal signal[m
[32m+[m[32m        - Technology: Faster competitors arrive[m
[32m+[m[32m        - Regime change: Market structure shifts[m
[32m+[m[32m        - Data democratization: Alternative data becomes mainstream[m
[32m+[m[41m        [m
[32m+[m[32m        RULE OF THUMB:[m
[32m+[m[32m        - Published signals decay in <1 year[m
[32m+[m[32m        - Alt data signals decay in 2-3 years[m
[32m+[m[32m        - Structural signals persist longer[m
[32m+[m[32m        """[m
[32m+[m[32m        # Calculate decay metrics[m
[32m+[m[32m        if historical_returns and len(historical_returns) >= 6:[m
[32m+[m[32m            # Split into first half and second half[m
[32m+[m[32m            midpoint = len(historical_returns) // 2[m
[32m+[m[32m            first_half_avg = sum(historical_returns[:midpoint]) / midpoint[m
[32m+[m[32m            second_half_avg = sum(historical_returns[midpoint:]) / (len(historical_returns) - midpoint)[m
[32m+[m[41m            [m
[32m+[m[32m            if first_half_avg > 0:[m
[32m+[m[32m                decay_rate = (first_half_avg - second_half_avg) / first_half_avg[m
[32m+[m[32m            else:[m
[32m+[m[32m                decay_rate = 0[m
[32m+[m[32m        else:[m
[32m+[m[32m            # Estimate based on signal type and time[m
[32m+[m[32m            decay_rate = 0.15 * (months_since_discovery / 12)  # 15% per year default[m
[32m+[m[41m        [m
[32m+[m[32m        # Classify decay rate[m
[32m+[m[32m        if decay_rate < 0.05:[m
[32m+[m[32m            decay_classification = EdgeDecayRate.PERMANENT[m
[32m+[m[32m            half_life_days = 9999[m
[32m+[m[32m        elif decay_rate < 0.15:[m
[32m+[m[32m            decay_classification = EdgeDecayRate.SLOW[m
[32m+[m[32m            half_life_days = 730  # 2 years[m
[32m+[m[32m        elif decay_rate < 0.30:[m
[32m+[m[32m            decay_classification = EdgeDecayRate.MODERATE[m
[32m+[m[32m            half_life_days = 365  # 1 year[m
[32m+[m[32m        elif decay_rate < 0.50:[m
[32m+[m[32m            decay_classification = EdgeDecayRate.FAST[m
[32m+[m[32m            half_life_days = 90  # 3 months[m
[32m+[m[32m        else:[m
[32m+[m[32m            decay_classification = EdgeDecayRate.CRITICAL[m
[32m+[m[32m            half_life_days = 30  # 1 month[m
[32m+[m[41m        [m
[32m+[m[32m        # Alert if critical[m
[32m+[m[32m        if decay_classification in [EdgeDecayRate.FAST, EdgeDecayRate.CRITICAL]:[m
[32m+[m[32m            self.edge_decay_alerts += 1[m
[32m+[m[32m            self.logger.warning(f"âš ï¸ EDGE DECAY ALERT: {signal_name} decay rate is {decay_classification.value}")[m
[32m+[m[41m        [m
[32m+[m[32m        return {[m
[32m+[m[32m            "signal_name": signal_name,[m
[32m+[m[32m            "decay_rate_annual": decay_rate,[m
[32m+[m[32m            "decay_classification": decay_classification.value,[m
[32m+[m[32m            "half_life_days": half_life_days,[m
[32m+[m[32m            "months_since_discovery": months_since_discovery,[m
[32m+[m[32m            "action_required": decay_classification in [EdgeDecayRate.FAST, EdgeDecayRate.CRITICAL],[m
[32m+[m[32m            "recommendation": self._get_decay_recommendation(decay_classification),[m
[32m+[m[32m        }[m
[32m+[m[41m    [m
[32m+[m[32m    def _get_decay_recommendation(self, decay: EdgeDecayRate) -> str:[m
[32m+[m[32m        """Get recommendation based on decay rate."""[m
[32m+[m[32m        recommendations = {[m
[32m+[m[32m            EdgeDecayRate.PERMANENT: "Structural advantage - maximize allocation",[m
[32m+[m[32m            EdgeDecayRate.SLOW: "Strong signal - maintain full allocation",[m
[32m+[m[32m            EdgeDecayRate.MODERATE: "Healthy decay - monitor monthly",[m
[32m+[m[32m            EdgeDecayRate.FAST: "Accelerating decay - reduce allocation, find replacement",[m
[32m+[m[32m            EdgeDecayRate.CRITICAL: "CRITICAL - exit within weeks, signal is compromised",[m
[32m+[m[32m        }[m
[32m+[m[32m        return recommendations.get(decay, "Unknown decay rate")[m
[32m+[m[41m    [m
[32m+[m[32m    # =========================================================================[m
[32m+[m[32m    # CROWDING DETECTION - "Are we alone or in a crowded trade?"[m
[32m+[m[32m    # =========================================================================[m
[32m+[m[41m    [m
[32m+[m[32m    def detect_crowding([m
[32m+[m[32m        self,[m
[32m+[m[32m        signal_name: str,[m
[32m+[m[32m        current_positions: List[str] = None,[m
[32m+[m[32m        market_metrics: Dict = None[m
[32m+[m[32m    ) -> Dict[str, Any]:[m
[32m+[m[32m        """[m
[32m+[m[32m        Detect if a trade/signal is becoming crowded.[m
[32m+[m[41m        [m
[32m+[m[32m        CROWDING INDICATORS:[m
[32m+[m[32m        - Short interest declining (everyone's long)[m
[32m+[m[32m        - Options skew flattening[m
[32m+[m[32m        - Similar 13F filings from funds[m
[32m+[m[32m        - Broker research convergence[m
[32m+[m[32m        - Retail attention (WSB, FinTwit)[m
[32m+[m[32m        - Price momentum without fundamental change[m
[32m+[m[32m        - Analyst upgrades clustering[m
[32m+[m[41m        [m
[32m+[m[32m        WHY IT MATTERS:[m
[32m+[m[32m        - Crowded trades unwind violently[m
[32m+[m[32m        - Exit risk > position risk[m
[32m+[m[32m        - Last in, first out (we want to be early out)[m
[32m+[m[32m        """[m
[32m+[m[32m        # Simulate crowding detection[m
[32m+[m[32m        crowding_score = random.uniform(0, 100)[m
[32m+[m[41m        [m
[32m+[m[32m        if crowding_score < 20:[m
[32m+[m[32m            crowding_level = CrowdingLevel.UNCROWDED[m
[32m+[m[32m            exit_risk = "low"[m
[32m+[m[32m            estimated_capital = random.uniform(10, 100)  # $10-100M[m
[32m+[m[32m        elif crowding_score < 40:[m
[32m+[m[32m            crowding_level = CrowdingLevel.EARLY[m
[32m+[m[32m            exit_risk = "low"[m
[32m+[m[32m            estimated_capital = random.uniform(100, 500)[m
[32m+[m[32m        elif crowding_score < 60:[m
[32m+[m[32m            crowding_level = CrowdingLevel.BUILDING[m
[32m+[m[32m            exit_risk = "moderate"[m
[32m+[m[32m            estimated_capital = random.uniform(500, 2000)[m
[32m+[m[32m        elif crowding_score < 80:[m
[32m+[m[32m            crowding_level = CrowdingLevel.CROWDED[m
[32m+[m[32m            exit_risk = "high"[m
[32m+[m[32m            estimated_capital = random.uniform(2000, 10000)[m
[32m+[m[32m        else:[m
[32m+[m[32m            crowding_level = CrowdingLevel.EXTREMELY_CROWDED[m
[32m+[m[32m            exit_risk = "critical"[m
[32m+[m[32m            estimated_capital = random.uniform(10000, 50000)[m
[32m+[m[41m        [m
[32m+[m[32m        # Alert if crowded[m
[32m+[m[32m        if crowding_level in [CrowdingLevel.CROWDED, CrowdingLevel.EXTREMELY_CROWDED]:[m
[32m+[m[32m            self.crowding_alerts += 1[m
[32m+[m[32m            self.logger.warning(f"âš ï¸ CROWDING ALERT: {signal_name} is {crowding_level.value}")[m
[32m+[m[41m        [m
[32m+[m[32m        return {[m
[32m+[m[32m            "signal_name": signal_name,[m
[32m+[m[32m            "crowding_score": crowding_score,[m
[32m+[m[32m            "crowding_level": crowding_level.value,[m
[32m+[m[32m            "estimated_capital_millions": estimated_capital,[m
[32m+[m[32m            "exit_risk": exit_risk,[m
[32m+[m[32m            "time_to_unwind_days": self._estimate_unwind_time(estimated_capital),[m
[32m+[m[32m            "recommendation": self._get_crowding_recommendation(crowding_level),[m
[32m+[m[32m        }[m
[32m+[m[41m    [m
[32m+[m[32m    def _estimate_unwind_time(self, capital_millions: float) -> int:[m
[32m+[m[32m        """Estimate time to unwind based on capital."""[m
[32m+[m[32m        if capital_millions < 100:[m
[32m+[m[32m            return 1[m
[32m+[m[32m        elif capital_millions < 500:[m
[32m+[m[32m            return 3[m
[32m+[m[32m        elif capital_millions < 2000:[m
[32m+[m[32m            return 7[m
[32m+[m[32m        elif capital_millions < 10000:[m
[32m+[m[32m            return 14[m
[32m+[m[32m        else:[m
[32m+[m[32m            return 30[m
[32m+[m[41m    [m
[32m+[m[32m    def _get_crowding_recommendation(self, crowding: CrowdingLevel) -> str:[m
[32m+[m[32m        """Get recommendation based on crowding level."""[m
[32m+[m[32m        recommendations = {[m
[32m+[m[32m            CrowdingLevel.UNCROWDED: "Ideal - maximize position",[m
[32m+[m[32m            CrowdingLevel.EARLY: "Good entry - scale in",[m
[32m+[m[32m            CrowdingLevel.BUILDING: "Monitor closely - reduce if momentum stalls",[m
[32m+[m[32m            CrowdingLevel.CROWDED: "CAUTION - trim position, plan exit",[m
[32m+[m[32m            CrowdingLevel.EXTREMELY_CROWDED: "EXIT NOW - unwind before the stampede",[m
[32m+[m[32m        }[m
[32m+[m[32m        return recommendations.get(crowding, "Unknown crowding level")[m
[32m+[m[41m    [m
[32m+[m[32m    # =========================================================================[m
[32m+[m[32m    # UNIQUENESS SCORING - "Is our edge proprietary?"[m
[32m+[m[32m    # =========================================================================[m
[32m+[m[41m    [m
[32m+[m[32m    def score_uniqueness([m
[32m+[m[32m        self,[m
[32m+[m[32m        signal_name: str,[m
[32m+[m[32m        data_source: str,[m
[32m+[m[32m        methodology: str,[m
[32m+[m[32m        time_horizon: str[m
[32m+[m[32m    ) -> Dict[str, Any]:[m
[32m+[m[32m        """[m
[32m+[m[32m        Score how unique/proprietary a signal is.[m
[32m+[m[41m        [m
[32m+[m[32m        UNIQUENESS FACTORS:[m
[32m+[m[32m        - Data source: Proprietary > Alternative > Public[m
[32m+[m[32m        - Methodology: Novel > Modified > Standard[m
[32m+[m[32m        - Time horizon: Non-standard > Standard[m
[32m+[m[32m        - Compute requirements: High > Low[m
[32m+[m[32m        - Domain expertise required: High > Low[m
[32m+[m[41m        [m
[32m+[m[32m        SCORING:[m
[32m+[m[32m        - 80-100: Highly proprietary, rare edge[m
[32m+[m[32m        - 60-80: Differentiated, some edge[m
[32m+[m[32m        - 40-60: Somewhat common, limited edge[m
[32m+[m[32m        - 20-40: Commodity signal, minimal edge[m
[32m+[m[32m        - 0-20: Everyone trades this, no edge[m
[32m+[m[32m        """[m
[32m+[m[32m        # Data source scoring[m
[32m+[m[32m        data_scores = {[m
[32m+[m[32m            "proprietary": 30,[m
[32m+[m[32m            "alternative_exclusive": 25,[m
[32m+[m[32m            "alternative_common": 15,[m
[32m+[m[32m            "vendor": 10,[m
[32m+[m[32m            "public": 5,[m
[32m+[m[32m            "free": 0,[m
[32m+[m[32m        }[m
[32m+[m[32m        data_score = data_scores.get(data_source, 10)[m
[32m+[m[41m        [m
[32m+[m[32m        # Methodology scoring[m
[32m+[m[32m        method_scores = {[m
[32m+[m[32m            "novel_ml": 30,[m
[32m+[m[32m            "proprietary_model": 25,[m
[32m+[m[32m            "modified_standard": 15,[m
[32m+[m[32m            "standard_ml": 10,[m
[32m+[m[32m            "simple_rules": 5,[m
[32m+[m[32m        }[m
[32m+[m[32m        method_score = method_scores.get(methodology, 10)[m
[32m+[m[41m        [m
[32m+[m[32m        # Time horizon scoring[m
[32m+[m[32m        horizon_scores = {[m
[32m+[m[32m            "unique": 20,[m
[32m+[m[32m            "non_standard": 15,[m
[32m+[m[32m            "intraday": 10,[m
[32m+[m[32m            "daily": 8,[m
[32m+[m[32m            "weekly": 5,[m
[32m+[m[32m            "monthly": 3,[m
[32m+[m[32m        }[m
[32m+[m[32m        horizon_score = horizon_scores.get(time_horizon, 8)[m
[32m+[m[41m        [m
[32m+[m[32m        # Random component for domain expertise[m
[32m+[m[32m        expertise_score = random.uniform(5, 20)[m
[32m+[m[41m        [m
[32m+[m[32m        total_score = min(100, data_score + method_score + horizon_score + expertise_score)[m
[32m+[m[41m        [m
[32m+[m[32m        # Replicability assessment[m
[32m+[m[32m        if total_score > 80:[m
[32m+[m[32m            replicability = "impossible"[m
[32m+[m[32m        elif total_score > 60:[m
[32m+[m[32m            replicability = "hard"[m
[32m+[m[32m        elif total_score > 40:[m
[32m+[m[32m            replicability = "moderate"[m
[32m+[m[32m        else:[m
[32m+[m[32m            replicability = "easy"[m
[32m+[m[41m        [m
[32m+[m[32m        return {[m
[32m+[m[32m            "signal_name": signal_name,[m
[32m+[m[32m            "uniqueness_score": total_score,[m
[32m+[m[32m            "data_source_score": data_score,[m
[32m+[m[32m            "methodology_score": method_score,[m
[32m+[m[32m            "time_horizon_score": horizon_score,[m
[32m+[m[32m            "replicability": replicability,[m
[32m+[m[32m            "edge_assessment": self._assess_edge(total_score),[m
[32m+[m[32m            "competitive_advantage": total_score > 60,[m
[32m+[m[32m        }[m
[32m+[m[41m    [m
[32m+[m[32m    def _assess_edge(self, score: float) -> str:[m
[32m+[m[32m        """Assess edge based on uniqueness score."""[m
[32m+[m[32m        if score > 80:[m
[32m+[m[32m            return "HIGHLY PROPRIETARY - Rare and defensible edge"[m
[32m+[m[32m        elif score > 60:[m
[32m+[m[32m            return "DIFFERENTIATED - Good edge, monitor decay"[m
[32m+[m[32m        elif score > 40:[m
[32m+[m[32m            return "LIMITED - Some edge, crowding risk"[m
[32m+[m[32m        elif score > 20:[m
[32m+[m[32m            return "COMMODITY - Minimal edge, replace"[m
[32m+[m[32m        else:[m
[32m+[m[32m            return "NO EDGE - Everyone trades this"[m
[32m+[m[41m    [m
[32m+[m[32m    # =========================================================================[m
[32m+[m[32m    # ADVERSARY MODELING - "Think like Goldman/Citadel"[m
[32m+[m[32m    # =========================================================================[m
[32m+[m[41m    [m
[32m+[m[32m    def model_adversary(self, adversary_type: str) -> Dict[str, Any]:[m
[32m+[m[32m        """[m
[32m+[m[32m        Model an adversary's likely behavior and capabilities.[m
[32m+[m[41m        [m
[32m+[m[32m        ADVERSARY THINKING:[m
[32m+[m[32m        - What data do they have that we don't?[m
[32m+[m[32m        - How much faster are they?[m
[32m+[m[32m        - What signals do they probably trade?[m
[32m+[m[32m        - Where do we overlap? (potential front-running)[m
[32m+[m[32m        - Where are we differentiated?[m
[32m+[m[32m        """[m
[32m+[m[32m        try:[m
[32m+[m[32m            adversary_enum = AdversaryType(adversary_type)[m
[32m+[m[32m            model = self.adversary_models.get(adversary_enum)[m
[32m+[m[32m        except ValueError:[m
[32m+[m[32m            return {"error": f"Unknown adversary: {adversary_type}"}[m
[32m+[m[41m        [m
[32m+[m[32m        if not model:[m
[32m+[m[32m            return {"error": f"No model for adversary: {adversary_type}"}[m
[32m+[m[41m        [m
[32m+[m[32m        return {[m
[32m+[m[32m            "adversary": model.adversary.value,[m
[32m+[m[32m            "capabilities": {[m
[32m+[m[32m                "data_advantages": model.data_advantage,[m
[32m+[m[32m                "compute_multiplier": model.compute_advantage,[m
[32m+[m[32m                "latency_advantage_ms": model.latency_advantage_ms,[m
[32m+[m[32m                "capital_base_billions": model.capital_base,[m
[32m+[m[32m            },[m
[32m+[m[32m            "strategies": {[m
[32m+[m[32m                "likely_strategies": model.likely_strategies,[m
[32m+[m[32m                "market_focus": model.market_focus,[m
[32m+[m[32m                "time_horizon": model.time_horizon,[m
[32m+[m[32m            },[m
[32m+[m[32m            "overlap_analysis": {[m
[32m+[m[32m                "signals_overlap": model.overlap_with_our_signals,[m
[32m+[m[32m                "front_running_risk": "high" if model.overlap_with_our_signals > 0.4 else "moderate" if model.overlap_with_our_signals > 0.2 else "low",[m
[32m+[m[32m            },[m
[32m+[m[32m            "recommendations": self._get_adversary_recommendations(model),[m
[32m+[m[32m        }[m
[32m+[m[41m    [m
[32m+[m[32m    def _get_adversary_recommendations(self, model: AdversaryModel) -> List[str]:[m
[32m+[m[32m        """Get recommendations for dealing with adversary."""[m
[32m+[m[32m        recs = [][m
[32m+[m[41m        [m
[32m+[m[32m        if model.latency_advantage_ms < 10:[m
[32m+[m[32m            recs.append("AVOID: Time-sensitive execution - they're faster")[m
[32m+[m[41m        [m
[32m+[m[32m        if model.compute_advantage > 50:[m
[32m+[m[32m            recs.append("AVOID: Compute-heavy strategies - they have more resources")[m
[32m+[m[41m        [m
[32m+[m[32m        if model.overlap_with_our_signals > 0.4:[m
[32m+[m[32m            recs.append("CAUTION: High signal overlap - monitor for front-running")[m
[32m+[m[32m            recs.append("DIVERSIFY: Find signals they're not trading")[m
[32m+[m[41m        [m
[32m+[m[32m        if "alt_data" in str(model.data_advantage):[m
[32m+[m[32m            recs.append("OPPORTUNITY: Unconventional data they might miss")[m
[32m+[m[41m        [m
[32m+[m[32m        recs.append(f"TIME HORIZON: Focus outside {model.time_horizon} for differentiation")[m
[32m+[m[41m        [m
[32m+[m[32m        return recs[m
[32m+[m[41m    [m
[32m+[m[32m    def assess_adversary_overlap(self, our_signals: List[str]) -> Dict[str, Any]:[m
[32m+[m[32m        """[m
[32m+[m[32m        Assess which adversaries might be trading our signals.[m
[32m+[m[41m        [m
[32m+[m[32m        Returns overlap assessment for each major adversary.[m
[32m+[m[32m        """[m
[32m+[m[32m        assessments = [][m
[32m+[m[41m        [m
[32m+[m[32m        for adversary_type, model in self.adversary_models.items():[m
[32m+[m[32m            # Check for signal overlap[m
[32m+[m[32m            their_signals = set(s.lower() for s in model.signals_they_probably_trade)[m
[32m+[m[32m            our_signals_lower = set(s.lower() for s in our_signals)[m
[32m+[m[41m            [m
[32m+[m[32m            overlap = their_signals.intersection(our_signals_lower)[m
[32m+[m[32m            overlap_pct = len(overlap) / len(our_signals) if our_signals else 0[m
[32m+[m[41m            [m
[32m+[m[32m            assessments.append({[m
[32m+[m[32m                "adversary": adversary_type.value,[m
[32m+[m[32m                "overlap_count": len(overlap),[m
[32m+[m[32m                "overlap_pct": overlap_pct,[m
[32m+[m[32m                "overlapping_signals": list(overlap)[:5],[m
[32m+[m[32m                "front_running_risk": "high" if overlap_pct > 0.3 else "moderate" if overlap_pct > 0.1 else "low",[m
[32m+[m[32m            })[m
[32m+[m[41m        [m
[32m+[m[32m        # Sort by overlap[m
[32m+[m[32m        assessments.sort(key=lambda x: x["overlap_pct"], reverse=True)[m
[32m+[m[41m        [m
[32m+[m[32m        return {[m
[32m+[m[32m            "our_signal_count": len(our_signals),[m
[32m+[m[32m            "highest_risk_adversary": assessments[0]["adversary"] if assessments else None,[m
[32m+[m[32m            "assessments": assessments,[m
[32m+[m[32m        }[m
[32m+[m[41m    [m
[32m+[m[32m    # =========================================================================[m
[32m+[m[32m    # INFORMATION LEAKAGE - "Are we leaving footprints?"[m
[32m+[m[32m    # =========================================================================[m
[32m+[m[41m    [m
[32m+[m[32m    def detect_information_leakage([m
[32m+[m[32m        self,[m
[32m+[m[32m        trades: List[Dict] = None,[m
[32m+[m[32m        execution_quality: Dict = None[m
[32m+[m[32m    ) -> Dict[str, Any]:[m
[32m+[m[32m        """[m
[32m+[m[32m        Detect if our trading is leaking information.[m
[32m+[m[41m        [m
[32m+[m[32m        LEAKAGE SIGNS:[m
[32m+[m[32m        - Market moves before our orders[m
[32m+[m[32m        - Unusual adverse selection[m
[32m+[m[32m        - Price impact higher than expected[m
[32m+[m[32m        - Predictable execution patterns[m
[32m+[m[32m        - Order flow being front-run[m
[32m+[m[41m        [m
[32m+[m[32m        PREVENTION:[m
[32m+[m[32m        - Randomize execution timing[m
[32m+[m[32m        - Use multiple brokers[m
[32m+[m[32m        - Obfuscate order sizes[m
[32m+[m[32m        - Avoid predictable patterns[m
[32m+[m[32m        """[m
[32m+[m[32m        # Simulate leakage detection[m
[32m+[m[32m        leakage_score = random.uniform(0, 100)[m
[32m+[m[41m        [m
[32m+[m[32m        indicators = {[m
[32m+[m[32m            "pre_trade_price_drift": random.uniform(-0.5, 0.5),  # Price drift before our orders[m
[32m+[m[32m            "adverse_selection_bps": random.uniform(0, 10),[m
[32m+[m[32m            "realized_vs_expected_impact": random.uniform(0.8, 1.5),[m
[32m+[m[32m            "execution_pattern_predictability": random.uniform(0, 1),[m
[32m+[m[32m        }[m
[32m+[m[41m        [m
[32m+[m[32m        # Assess leakage[m
[32m+[m[32m        if indicators["pre_trade_price_drift"] > 0.2:[m
[32m+[m[32m            leakage_detected = True[m
[32m+[m[32m            leakage_type = "front_running"[m
[32m+[m[32m        elif indicators["adverse_selection_bps"] > 5:[m
[32m+[m[32m            leakage_detected = True[m
[32m+[m[32m            leakage_type = "adverse_selection"[m
[32m+[m[32m        elif indicators["realized_vs_expected_impact"] > 1.3:[m
[32m+[m[32m            leakage_detected = True[m
[32m+[m[32m            leakage_type = "information_leakage"[m
[32m+[m[32m        else:[m
[32m+[m[32m            leakage_detected = False[m
[32m+[m[32m            leakage_type = "none"[m
[32m+[m[41m        [m
[32m+[m[32m        return {[m
[32m+[m[32m            "leakage_detected": leakage_detected,[m
[32m+[m[32m            "leakage_type": leakage_type,[m
[32m+[m[32m            "leakage_score": leakage_score,[m
[32m+[m[32m            "indicators": indicators,[m
[32m+[m[32m            "recommendations": self._get_leakage_recommendations(leakage_type),[m
[32m+[m[32m        }[m
[32m+[m[41m    [m
[32m+[m[32m    def _get_leakage_recommendations(self, leakage_type: str) -> List[str]:[m
[32m+[m[32m        """Get recommendations for addressing leakage."""[m
[32m+[m[32m        if leakage_type == "none":[m
[32m+[m[32m            return ["No leakage detected - maintain current execution"][m
[32m+[m[41m        [m
[32m+[m[32m        recs = [[m
[32m+[m[32m            "IMMEDIATE: Review broker relationships",[m
[32m+[m[32m            "IMMEDIATE: Randomize execution timing",[m
[32m+[m[32m            "IMMEDIATE: Vary order sizes",[m
[32m+[m[32m        ][m
[32m+[m[41m        [m
[32m+[m[32m        if leakage_type == "front_running":[m
[32m+[m[32m            recs.extend([[m
[32m+[m[32m                "CRITICAL: Change execution venue",[m
[32m+[m[32m                "CRITICAL: Split orders across brokers",[m
[32m+[m[32m                "CRITICAL: Add noise to order flow",[m
[32m+[m[32m            ])[m
[32m+[m[32m        elif leakage_type == "adverse_selection":[m
[32m+[m[32m            recs.extend([[m
[32m+[m[32m                "Review counterparty exposure",[m
[32m+[m[32m                "Improve execution algorithm",[m
[32m+[m[32m                "Consider dark pool usage",[m
[32m+[m[32m            ])[m
[32m+[m[32m        elif leakage_type == "information_leakage":[m
[32m+[m[32m            recs.extend([[m
[32m+[m[32m                "Audit information access",[m
[32m+[m[32m                "Review communication protocols",[m
[32m+[m[32m                "Implement need-to-know basis",[m
[32m+[m[32m            ])[m
[32m+[m[41m        [m
[32m+[m[32m        return recs[m
[32m+[m[41m    [m
[32m+[m[32m    # =========================================================================[m
[32m+[m[32m    # TASK HANDLERS[m
[32m+[m[32m    # =========================================================================[m
[32m+[m[41m    [m
[32m+[m[32m    def _handle_inject_fault(self, params: Dict) -> Dict:[m
[32m+[m[32m        fault = self.inject_fault([m
[32m+[m[32m            fault_type=params.get("fault_type", "latency"),[m
[32m+[m[32m            target_system=params.get("target_system", "api_gateway"),[m
[32m+[m[32m            severity=params.get("severity", "moderate"),[m
[32m+[m[32m            duration_seconds=params.get("duration_seconds", 60),[m
[32m+[m[32m        )[m
[32m+[m[32m        return {"status": "success", "fault": fault.to_dict()}[m
[32m+[m[41m    [m
[32m+[m[32m    def _handle_stress_test(self, params: Dict) -> Dict:[m
[32m+[m[32m        results = self.run_chaos_engineering_suite()[m
[32m+[m[32m        return {"status": "success", "results": results}[m
[32m+[m[41m    [m
[32m+[m[32m    def _handle_test_recovery(self, params: Dict) -> Dict:[m
[32m+[m[32m        # Run recovery-focused tests[m
[32m+[m[32m        fault = self.inject_fault("cascade_failure", "core_systems", "severe", 120)[m
[32m+[m[32m        return {[m
[32m+[m[32m            "status": "success",[m
[32m+[m[32m            "recovery_test": fault.to_dict(),[m
[32m+[m[32m            "recovery_time_seconds": fault.recovery_time_seconds,[m
[32m+[m[32m            "passed": fault.passed,[m
[32m+[m[32m        }[m
[32m+[m[41m    [m
[32m+[m[32m    def _handle_edge_decay(self, params: Dict) -> Dict:[m
[32m+[m[32m        result = self.measure_edge_decay([m
[32m+[m[32m            signal_name=params.get("signal_name", "unknown"),[m
[32m+[m[32m            historical_returns=params.get("historical_returns"),[m
[32m+[m[32m            months_since_discovery=params.get("months_since_discovery", 0),[m
[32m+[m[32m        )[m
[32m+[m[32m        return {"status": "success", "decay_analysis": result}[m
[32m+[m[41m    [m
[32m+[m[32m    def _handle_half_life(self, params: Dict) -> Dict:[m
[32m+[m[32m        result = self.measure_edge_decay([m
[32m+[m[32m            signal_name=params.get("signal_name", "unknown"),[m
[32m+[m[32m            months_since_discovery=params.get("months_since_discovery", 0),[m
[32m+[m[32m        )[m
[32m+[m[32m        return {"status": "success", "half_life_days": result["half_life_days"]}[m
[32m+[m[41m    [m
[32m+[m[32m    def _handle_track_signal(self, params: Dict) -> Dict:[m
[32m+[m[32m        # Create edge signal tracking[m
[32m+[m[32m        signal = EdgeSignal([m
[32m+[m[32m            signal_id=f"sig_{hashlib.sha256(f'{params.get("signal_name")}{datetime.now()}'.encode()).hexdigest()[:8]}",[m
[32m+[m[32m            signal_name=params.get("signal_name", "unknown"),[m
[32m+[m[32m            signal_type=params.get("signal_type", "unknown"),[m
[32m+[m[32m            edge_bps=params.get("edge_bps", 0),[m
[32m+[m[32m            decay_rate=EdgeDecayRate.MODERATE,[m
[32m+[m[32m            discovery_date=datetime.now(),[m
[32m+[m[32m            expected_half_life_days=365,[m
[32m+[m[32m            crowding_level=CrowdingLevel.EARLY,[m
[32m+[m[32m            estimated_capital_trading=0,[m
[32m+[m[32m            uniqueness_score=50,[m
[32m+[m[32m            replicability="moderate",[m
[32m+[m[32m            data_source_uniqueness="standard",[m
[32m+[m[32m            citadel_likely_knows=False,[m
[32m+[m[32m            renaissance_likely_knows=False,[m
[32m+[m[32m            two_sigma_likely_knows=False,[m
[32m+[m[32m        )[m
[32m+[m[32m        self.edge_signals.append(signal)[m
[32m+[m[32m        return {"status": "success", "signal_tracked": signal.to_dict()}[m
[32m+[m[41m    [m
[32m+[m[32m    def _handle_detect_crowding(self, params: Dict) -> Dict:[m
[32m+[m[32m        result = self.detect_crowding([m
[32m+[m[32m            signal_name=params.get("signal_name", "unknown"),[m
[32m+[m[32m            current_positions=params.get("positions"),[m
[32m+[m[32m            market_metrics=params.get("market_metrics"),[m
[32m+[m[32m        )[m
[32m+[m[32m        return {"status": "success", "crowding_analysis": result}[m
[32m+[m[41m    [m
[32m+[m[32m    def _handle_estimate_capital(self, params: Dict) -> Dict:[m
[32m+[m[32m        result = self.detect_crowding(params.get("signal_name", "unknown"))[m
[32m+[m[32m        return {"status": "success", "estimated_capital_millions": result["estimated_capital_millions"]}[m
[32m+[m[41m    [m
[32m+[m[32m    def _handle_score_uniqueness(self, params: Dict) -> Dict:[m
[32m+[m[32m        result = self.score_uniqueness([m
[32m+[m[32m            signal_name=params.get("signal_name", "unknown"),[m
[32m+[m[32m            data_source=params.get("data_source", "public"),[m
[32m+[m[32m            methodology=params.get("methodology", "standard_ml"),[m
[32m+[m[32m            time_horizon=params.get("time_horizon", "daily"),[m
[32m+[m[32m        )[m
[32m+[m[32m        return {"status": "success", "uniqueness_analysis": result}[m
[32m+[m[41m    [m
[32m+[m[32m    def _handle_model_adversary(self, params: Dict) -> Dict:[m
[32m+[m[32m        result = self.model_adversary(params.get("adversary", "citadel"))[m
[32m+[m[32m        return {"status": "success", "adversary_model": result}[m
[32m+[m[41m    [m
[32m+[m[32m    def _handle_assess_overlap(self, params: Dict) -> Dict:[m
[32m+[m[32m        result = self.assess_adversary_overlap(params.get("signals", []))[m
[32m+[m[32m        return {"status": "success", "overlap_assessment": result}[m
[32m+[m[41m    [m
[32m+[m[32m    def _handle_detect_leakage(self, params: Dict) -> Dict:[m
[32m+[m[32m        result = self.detect_information_leakage([m
[32m+[m[32m            trades=params.get("trades"),[m
[32m+[m[32m            execution_quality=params.get("execution_quality"),[m
[32m+[m[32m        )[m
[32m+[m[32m        return {"status": "success", "leakage_analysis": result}[m
[32m+[m[41m    [m
[32m+[m[32m    def _handle_status(self, params: Dict) -> Dict:[m
[32m+[m[32m        return {[m
[32m+[m[32m            "status": "success",[m
[32m+[m[32m            "agent": "NOBUSAgent",[m
[32m+[m[32m            "total_faults_injected": self.total_faults_injected,[m
[32m+[m[32m            "faults_passed": self.faults_passed,[m
[32m+[m[32m            "faults_failed": self.faults_failed,[m
[32m+[m[32m            "fault_pass_rate