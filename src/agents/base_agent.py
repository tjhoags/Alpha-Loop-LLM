"""================================================================================
BASE AGENT - Foundation for All Trading Agents
================================================================================
Abstract base class that all trading agents inherit from. Provides:

1. Lifecycle Management: Creation, training, validation, execution, termination
2. Performance Tracking: Sharpe, Sortino, win rate, drawdown
3. Risk Controls: Position limits, stop losses, drawdown protection
4. Signal Generation: Standardized signal format
5. Learning: Online learning, hyperparameter mutation

Each specialized agent implements:
- generate_features(): Create strategy-specific features
- predict(): Generate trading signals
- update_model(): Online learning from new data

================================================================================
"""

import pickle
import random
import uuid
from abc import ABC, abstractmethod
from dataclasses import asdict, dataclass, field
from datetime import datetime
from enum import Enum
from pathlib import Path
from typing import Dict, List, Optional, Tuple

import numpy as np
import pandas as pd
from loguru import logger

try:
    from sklearn.model_selection import TimeSeriesSplit
    from sklearn.preprocessing import StandardScaler
    HAS_SKLEARN = True
except ImportError:
    HAS_SKLEARN = False

from src.config.settings import get_settings


class AgentStatus(Enum):
    """Agent lifecycle status."""

    INITIALIZING = "initializing"
    TRAINING = "training"
    VALIDATING = "validating"
    ACTIVE = "active"
    PAPER_TRADING = "paper_trading"
    LIVE_TRADING = "live_trading"
    SUSPENDED = "suspended"
    TERMINATED = "terminated"


@dataclass
class AgentConfig:
    """Configuration for a trading agent."""

    agent_id: str = field(default_factory=lambda: str(uuid.uuid4())[:8])
    agent_type: str = "base"
    name: str = ""
    symbol: str = ""

    # Core Hyperparameters
    lookback_window: int = 60
    prediction_horizon: int = 1
    confidence_threshold: float = 0.55

    # Model Parameters
    n_estimators: int = 500
    max_depth: int = 6
    learning_rate: float = 0.01
    min_samples_leaf: int = 20
    subsample: float = 0.8

    # Feature Flags
    use_momentum_features: bool = True
    use_mean_reversion_features: bool = True
    use_volume_features: bool = True
    use_volatility_features: bool = True
    use_sentiment_features: bool = False
    use_macro_features: bool = False
    use_fundamental_features: bool = False

    # Risk Parameters
    max_position_pct: float = 0.05  # Max 5% of portfolio
    stop_loss_pct: float = 0.02     # 2% stop loss
    take_profit_pct: float = 0.05   # 5% take profit
    max_daily_trades: int = 10

    # Metadata
    created_at: datetime = field(default_factory=datetime.now)
    parent_id: Optional[str] = None
    generation: int = 1

    def to_dict(self) -> Dict:
        """Convert to dictionary."""
        d = asdict(self)
        d["created_at"] = self.created_at.isoformat()
        return d

    @classmethod
    def from_dict(cls, d: Dict) -> "AgentConfig":
        """Create from dictionary."""
        if "created_at" in d and isinstance(d["created_at"], str):
            d["created_at"] = datetime.fromisoformat(d["created_at"])
        return cls(**d)


@dataclass
class AgentPerformance:
    """Performance metrics for an agent."""

    agent_id: str

    # Returns metrics
    total_return: float = 0.0
    annualized_return: float = 0.0
    volatility: float = 0.0

    # Risk-adjusted metrics
    sharpe_ratio: float = 0.0
    sortino_ratio: float = 0.0
    calmar_ratio: float = 0.0

    # Trade metrics
    total_trades: int = 0
    winning_trades: int = 0
    losing_trades: int = 0
    win_rate: float = 0.0
    profit_factor: float = 0.0

    # Drawdown
    max_drawdown: float = 0.0
    avg_drawdown: float = 0.0
    max_drawdown_duration: int = 0

    # Model metrics
    accuracy: float = 0.0
    precision: float = 0.0
    recall: float = 0.0
    auc: float = 0.5

    # Timestamps
    last_updated: datetime = field(default_factory=datetime.now)
    trading_days: int = 0

    def to_dict(self) -> Dict:
        d = asdict(self)
        d["last_updated"] = self.last_updated.isoformat()
        return d


@dataclass
class Signal:
    """Trading signal generated by an agent."""

    agent_id: str
    symbol: str
    timestamp: datetime

    # Signal
    direction: str  # 'BUY', 'SELL', 'HOLD'
    confidence: float  # 0.0 to 1.0

    # Position sizing
    suggested_size: float  # Fraction of portfolio

    # Price targets
    entry_price: Optional[float] = None
    stop_loss: Optional[float] = None
    take_profit: Optional[float] = None

    # Metadata
    features_used: List[str] = field(default_factory=list)
    model_version: str = "1.0"

    def to_dict(self) -> Dict:
        d = asdict(self)
        d["timestamp"] = self.timestamp.isoformat()
        return d


class BaseAgent(ABC):
    """Abstract base class for all trading agents.

    Lifecycle:
    1. __init__(): Initialize with config
    2. load_data(): Fetch historical data
    3. generate_features(): Create features
    4. train(): Train model on historical data
    5. validate(): Out-of-sample validation
    6. activate(): Start generating signals
    7. generate_signal(): Create trading signals
    8. update(): Online learning from new data
    9. terminate(): Clean shutdown
    """

    def __init__(self, config: Optional[AgentConfig] = None):
        """Initialize the agent."""
        self.config = config or AgentConfig()
        self.settings = get_settings()
        self.status = AgentStatus.INITIALIZING
        self.performance = AgentPerformance(agent_id=self.config.agent_id)

        # Model state
        self.model = None
        self.scaler = StandardScaler() if HAS_SKLEARN else None
        self.feature_names: List[str] = []

        # Data
        self.data: Optional[pd.DataFrame] = None
        self.features: Optional[pd.DataFrame] = None
        self.labels: Optional[pd.Series] = None

        # Trade history
        self.signals: List[Signal] = []
        self.trades: List[Dict] = []
        self.equity_curve: List[float] = []

        # Paths
        self.model_path = self.settings.models_dir / f"agent_{self.config.agent_id}.pkl"

        logger.info(f"Agent {self.config.agent_id} ({self.config.agent_type}) initialized")

    # =========================================================================
    # ABSTRACT METHODS - Must be implemented by subclasses
    # =========================================================================

    @abstractmethod
    def generate_features(self, df: pd.DataFrame) -> pd.DataFrame:
        """Generate strategy-specific features.

        Args:
        ----
            df: OHLCV DataFrame

        Returns:
        -------
            DataFrame with features
        """

    @abstractmethod
    def predict(self, features: pd.DataFrame) -> Tuple[str, float]:
        """Generate prediction from features.

        Args:
        ----
            features: Feature DataFrame (single row or batch)

        Returns:
        -------
            (direction, confidence) tuple
        """

    # =========================================================================
    # DATA LOADING
    # =========================================================================

    def load_data(self, symbol: Optional[str] = None, days: int = 365) -> pd.DataFrame:
        """Load historical data from database."""
        symbol = symbol or self.config.symbol

        try:
            from sqlalchemy import create_engine, text
            engine = create_engine(self.settings.sqlalchemy_url)

            query = text("""
                SELECT symbol, timestamp, [open], high, low, [close], volume
                FROM price_bars
                WHERE symbol = :symbol
                ORDER BY timestamp ASC
            """)

            with engine.connect() as conn:
                df = pd.read_sql(query, conn, params={"symbol": symbol})

            if df.empty:
                logger.warning(f"No data found for {symbol}")
                return pd.DataFrame()

            df["timestamp"] = pd.to_datetime(df["timestamp"])
            df = df.set_index("timestamp")

            # Rename columns if needed
            df.columns = df.columns.str.lower()

            self.data = df
            logger.info(f"Loaded {len(df)} rows for {symbol}")
            return df

        except Exception as e:
            logger.error(f"Error loading data: {e}")
            return pd.DataFrame()

    # =========================================================================
    # CORE FEATURES (Common to all agents)
    # =========================================================================

    def _base_features(self, df: pd.DataFrame) -> pd.DataFrame:
        """Generate base features used by all agents."""
        features = pd.DataFrame(index=df.index)

        # Returns
        features["returns_1d"] = df["close"].pct_change(1)
        features["returns_5d"] = df["close"].pct_change(5)
        features["returns_20d"] = df["close"].pct_change(20)

        # Volatility
        features["volatility_20d"] = features["returns_1d"].rolling(20).std()
        features["volatility_60d"] = features["returns_1d"].rolling(60).std()

        # Volume
        features["volume_sma_20"] = df["volume"].rolling(20).mean()
        features["volume_ratio"] = df["volume"] / features["volume_sma_20"]

        # Price position
        features["high_20d"] = df["high"].rolling(20).max()
        features["low_20d"] = df["low"].rolling(20).min()
        features["range_position"] = (df["close"] - features["low_20d"]) / (features["high_20d"] - features["low_20d"] + 1e-10)

        return features

    # =========================================================================
    # TRAINING
    # =========================================================================

    def prepare_training_data(self) -> Tuple[pd.DataFrame, pd.Series]:
        """Prepare features and labels for training."""
        if self.data is None or self.data.empty:
            raise ValueError("No data loaded. Call load_data() first.")

        # Generate features
        self.features = self.generate_features(self.data)

        # Create labels (future returns)
        horizon = self.config.prediction_horizon
        future_returns = self.data["close"].pct_change(horizon).shift(-horizon)
        self.labels = (future_returns > 0).astype(int)

        # Align and drop NaN
        valid_idx = self.features.dropna().index.intersection(self.labels.dropna().index)
        X = self.features.loc[valid_idx]
        y = self.labels.loc[valid_idx]

        self.feature_names = list(X.columns)

        return X, y

    def train(self, X: Optional[pd.DataFrame] = None, y: Optional[pd.Series] = None) -> Dict[str, float]:
        """Train the agent's model.

        Returns
        -------
            Dictionary of training metrics
        """
        self.status = AgentStatus.TRAINING

        if X is None or y is None:
            X, y = self.prepare_training_data()

        try:
            from sklearn.model_selection import cross_val_score
            from xgboost import XGBClassifier

            # Scale features
            X_scaled = self.scaler.fit_transform(X)

            # Create model
            self.model = XGBClassifier(
                n_estimators=self.config.n_estimators,
                max_depth=self.config.max_depth,
                learning_rate=self.config.learning_rate,
                subsample=self.config.subsample,
                min_child_weight=self.config.min_samples_leaf,
                n_jobs=-1,
                random_state=42,
            )

            # Time series cross-validation
            tscv = TimeSeriesSplit(n_splits=5)
            cv_scores = cross_val_score(self.model, X_scaled, y, cv=tscv, scoring="roc_auc")

            # Final fit
            self.model.fit(X_scaled, y)

            # Metrics
            train_pred = self.model.predict(X_scaled)
            train_proba = self.model.predict_proba(X_scaled)[:, 1]

            from sklearn.metrics import accuracy_score, roc_auc_score

            metrics = {
                "cv_auc_mean": float(np.mean(cv_scores)),
                "cv_auc_std": float(np.std(cv_scores)),
                "train_accuracy": float(accuracy_score(y, train_pred)),
                "train_auc": float(roc_auc_score(y, train_proba)),
            }

            # Update performance
            self.performance.auc = metrics["cv_auc_mean"]
            self.performance.accuracy = metrics["train_accuracy"]

            logger.info(f"Agent {self.config.agent_id} trained: AUC={metrics['cv_auc_mean']:.4f}")

            return metrics

        except Exception as e:
            logger.error(f"Training error: {e}")
            return {"error": str(e)}

    # =========================================================================
    # SIGNAL GENERATION
    # =========================================================================

    def generate_signal(self, current_data: Optional[pd.DataFrame] = None) -> Signal:
        """Generate a trading signal based on current market data.

        Args:
        ----
            current_data: Recent OHLCV data (uses self.data if None)

        Returns:
        -------
            Signal object
        """
        if current_data is None:
            current_data = self.data

        if current_data is None or len(current_data) < self.config.lookback_window:
            return Signal(
                agent_id=self.config.agent_id,
                symbol=self.config.symbol,
                timestamp=datetime.now(),
                direction="HOLD",
                confidence=0.0,
                suggested_size=0.0,
            )

        # Generate features for latest data
        features = self.generate_features(current_data)
        latest_features = features.iloc[[-1]].dropna(axis=1)

        # Get prediction
        direction, confidence = self.predict(latest_features)

        # Calculate position size based on confidence
        if confidence >= self.config.confidence_threshold:
            suggested_size = min(
                self.config.max_position_pct * (confidence - 0.5) * 2,
                self.config.max_position_pct,
            )
        else:
            direction = "HOLD"
            suggested_size = 0.0

        # Calculate price targets
        current_price = current_data["close"].iloc[-1]

        signal = Signal(
            agent_id=self.config.agent_id,
            symbol=self.config.symbol,
            timestamp=datetime.now(),
            direction=direction,
            confidence=confidence,
            suggested_size=suggested_size,
            entry_price=current_price,
            stop_loss=current_price * (1 - self.config.stop_loss_pct) if direction == "BUY" else current_price * (1 + self.config.stop_loss_pct),
            take_profit=current_price * (1 + self.config.take_profit_pct) if direction == "BUY" else current_price * (1 - self.config.take_profit_pct),
            features_used=self.feature_names[:10],
        )

        self.signals.append(signal)
        return signal

    # =========================================================================
    # PERFORMANCE TRACKING
    # =========================================================================

    def update_performance(self, trade_result: Dict) -> None:
        """Update performance metrics after a trade."""
        self.trades.append(trade_result)

        # Update counts
        self.performance.total_trades += 1
        if trade_result.get("pnl", 0) > 0:
            self.performance.winning_trades += 1
        else:
            self.performance.losing_trades += 1

        # Update win rate
        if self.performance.total_trades > 0:
            self.performance.win_rate = self.performance.winning_trades / self.performance.total_trades

        # Update equity curve
        pnl = trade_result.get("pnl", 0)
        if self.equity_curve:
            self.equity_curve.append(self.equity_curve[-1] + pnl)
        else:
            self.equity_curve.append(100000 + pnl)  # Start with 100k

        # Calculate drawdown
        equity = np.array(self.equity_curve)
        peaks = np.maximum.accumulate(equity)
        drawdowns = (peaks - equity) / peaks
        self.performance.max_drawdown = float(np.max(drawdowns))

        # Calculate Sharpe
        if len(self.trades) >= 20:
            returns = pd.Series([t.get("return", 0) for t in self.trades])
            self.performance.sharpe_ratio = float(returns.mean() / (returns.std() + 1e-10) * np.sqrt(252))

        self.performance.last_updated = datetime.now()

    # =========================================================================
    # MUTATION / EVOLUTION
    # =========================================================================

    def mutate(self, mutation_rate: float = 0.2) -> "BaseAgent":
        """Create a mutated copy of this agent.

        Args:
        ----
            mutation_rate: Probability of mutating each parameter

        Returns:
        -------
            New agent with mutated hyperparameters
        """
        # Copy config
        new_config = AgentConfig(**asdict(self.config))
        new_config.agent_id = str(uuid.uuid4())[:8]
        new_config.parent_id = self.config.agent_id
        new_config.generation = self.config.generation + 1

        # Mutate hyperparameters
        if random.random() < mutation_rate:
            new_config.lookback_window = int(self.config.lookback_window * random.uniform(0.7, 1.3))

        if random.random() < mutation_rate:
            new_config.n_estimators = int(self.config.n_estimators * random.uniform(0.8, 1.2))

        if random.random() < mutation_rate:
            new_config.max_depth = max(3, min(10, self.config.max_depth + random.randint(-2, 2)))

        if random.random() < mutation_rate:
            new_config.learning_rate = self.config.learning_rate * random.uniform(0.5, 2.0)

        if random.random() < mutation_rate:
            new_config.confidence_threshold = max(0.5, min(0.9, self.config.confidence_threshold + random.uniform(-0.1, 0.1)))

        # Create new agent
        new_agent = self.__class__(config=new_config)

        logger.info(f"Mutated agent {self.config.agent_id} -> {new_config.agent_id} (gen {new_config.generation})")

        return new_agent

    # =========================================================================
    # PERSISTENCE
    # =========================================================================

    def save(self, path: Optional[Path] = None) -> None:
        """Save agent state to disk."""
        path = path or self.model_path

        state = {
            "config": self.config.to_dict(),
            "model": self.model,
            "scaler": self.scaler,
            "feature_names": self.feature_names,
            "performance": self.performance.to_dict(),
            "signals": [s.to_dict() for s in self.signals[-100:]],  # Last 100 signals
            "trades": self.trades[-1000:],  # Last 1000 trades
            "equity_curve": self.equity_curve[-1000:],
        }

        with open(path, "wb") as f:
            pickle.dump(state, f)

        logger.info(f"Agent {self.config.agent_id} saved to {path}")

    @classmethod
    def load(cls, path: Path) -> "BaseAgent":
        """Load agent from disk."""
        with open(path, "rb") as f:
            state = pickle.load(f)

        config = AgentConfig.from_dict(state["config"])
        agent = cls(config=config)
        agent.model = state["model"]
        agent.scaler = state["scaler"]
        agent.feature_names = state["feature_names"]
        agent.performance = AgentPerformance(**state["performance"])
        agent.trades = state.get("trades", [])
        agent.equity_curve = state.get("equity_curve", [])

        logger.info(f"Agent {config.agent_id} loaded from {path}")

        return agent

    # =========================================================================
    # LIFECYCLE
    # =========================================================================

    def activate(self) -> None:
        """Activate the agent for trading."""
        if self.model is None:
            raise ValueError("Cannot activate untrained agent")
        self.status = AgentStatus.ACTIVE
        logger.info(f"Agent {self.config.agent_id} activated")

    def suspend(self) -> None:
        """Suspend the agent."""
        self.status = AgentStatus.SUSPENDED
        logger.info(f"Agent {self.config.agent_id} suspended")

    def terminate(self) -> None:
        """Terminate the agent."""
        self.status = AgentStatus.TERMINATED
        self.save()
        logger.info(f"Agent {self.config.agent_id} terminated")

    def __repr__(self) -> str:
        return f"{self.__class__.__name__}(id={self.config.agent_id}, status={self.status.value}, sharpe={self.performance.sharpe_ratio:.2f})"


