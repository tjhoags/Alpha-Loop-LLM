"""================================================================================
RETAIL ARBITRAGE AGENT
================================================================================
Author: Alpha Loop Capital, LLC

Specialized agent for exploiting retail trading inefficiencies in small/mid cap
stocks. This agent hunts for bad bid/ask spreads, odd lot imbalances, stale
quotes, and retail panic/euphoria patterns.

Tier: STRATEGY (5)
Reports To: SCOUT â†’ HOAGS
Cluster: arbitrage

Core Strategies:
1. Bad Bid/Ask Exploitation - Wide spreads from low liquidity
2. Odd Lot Scalping - Retail orders creating temporary mispricings
3. Stale Quote Capture - Market makers not updating fast enough
4. Retail Panic Fade - Buy capitulation, sell euphoria
5. Momentum Exhaustion - Fade overextended retail chasing

Target Universe: Small/mid caps <$10B with high retail activity
================================================================================
"""

import logging
import uuid
from dataclasses import dataclass
from datetime import datetime
from enum import Enum
from typing import TYPE_CHECKING, Any, Dict, List, Optional

from src.core.agent_base import AgentTier, BaseAgent, ThinkingMode

if TYPE_CHECKING:
    import pandas as pd
from src.ml.small_mid_cap_models import MeanReversionModel, RetailArbitrageModel

logger = logging.getLogger(__name__)


class RetailSignalType(Enum):
    """Types of retail inefficiency signals."""

    WIDE_SPREAD = "wide_spread"
    STALE_QUOTE = "stale_quote"
    RETAIL_PANIC = "retail_panic"
    RETAIL_EUPHORIA = "retail_euphoria"
    MOMENTUM_EXHAUSTION = "momentum_exhaustion"
    LIQUIDITY_VACUUM = "liquidity_vacuum"
    ODD_LOT_IMBALANCE = "odd_lot_imbalance"


class TradeUrgency(Enum):
    """How quickly to act on signal."""

    IMMEDIATE = "immediate"  # Execute within seconds
    FAST = "fast"            # Execute within minutes
    STANDARD = "standard"    # Can wait for better entry
    PATIENT = "patient"      # Build position slowly


@dataclass
class RetailArbitrageSignal:
    """Signal generated by the Retail Arbitrage Agent."""

    signal_id: str
    signal_type: RetailSignalType
    symbol: str
    timestamp: datetime

    # Direction and sizing
    direction: str  # "long", "short"
    confidence: float  # 0-1
    suggested_size_pct: float  # % of portfolio

    # Pricing
    current_price: float
    fair_value: float
    edge_pct: float

    # Entry/Exit
    entry_price: float
    target_price: float
    stop_loss: float
    urgency: TradeUrgency

    # Context
    retail_inefficiency_score: float
    reasoning: str

    # Model predictions
    model_probability: float
    model_confidence: float

    def to_dict(self) -> Dict:
        return {
            "signal_id": self.signal_id,
            "type": self.signal_type.value,
            "symbol": self.symbol,
            "direction": self.direction,
            "confidence": round(self.confidence, 3),
            "edge_pct": round(self.edge_pct, 4),
            "entry": self.entry_price,
            "target": self.target_price,
            "stop": self.stop_loss,
            "urgency": self.urgency.value,
            "reasoning": self.reasoning,
        }


class RetailArbitrageAgent(BaseAgent):
    """Agent specialized in exploiting retail trading inefficiencies.

    Uses ML models to detect when retail flow creates mispricings,
    then generates actionable trade signals.
    """

    # Target universe
    TARGET_MARKET_CAP_MAX = 10_000_000_000  # $10B

    # Signal thresholds
    MIN_CONFIDENCE = 0.55
    MIN_EDGE_PCT = 0.005  # 0.5% minimum edge
    MAX_SPREAD_PCT = 0.03  # 3% max spread to trade

    def __init__(self):
        super().__init__(
            name="RetailArbitrage",
            tier=AgentTier.STRATEGY,
            capabilities=[
                # Detection
                "retail_flow_detection",
                "spread_analysis",
                "stale_quote_detection",
                "odd_lot_analysis",
                "panic_detection",
                "euphoria_detection",
                "momentum_exhaustion_detection",

                # Analysis
                "fair_value_calculation",
                "edge_calculation",
                "entry_optimization",
                "position_sizing",

                # ML
                "retail_inefficiency_scoring",
                "model_inference",
                "confidence_calibration",

                # Execution
                "signal_generation",
                "urgency_classification",
                "risk_assessment",
            ],
            user_id="TJH",
        )

        # Models
        self.retail_model: Optional[RetailArbitrageModel] = None
        self.mean_rev_model: Optional[MeanReversionModel] = None
        self._models_loaded = False

        # Signal tracking
        self.signals_generated: List[RetailArbitrageSignal] = []
        self.signals_executed = 0
        self.total_edge_captured = 0.0

        # Configuration
        self.config = {
            "min_confidence": self.MIN_CONFIDENCE,
            "min_edge_pct": self.MIN_EDGE_PCT,
            "max_spread_pct": self.MAX_SPREAD_PCT,
            "max_position_size_pct": 0.05,  # 5% max per position
            "default_stop_pct": 0.02,  # 2% stop loss
            "default_target_pct": 0.03,  # 3% profit target
        }

        # Active thinking mode for this agent
        self.primary_thinking_mode = ThinkingMode.BEHAVIORAL

    def load_models(self, retail_model_path: str = None, mean_rev_model_path: str = None):
        """Load trained ML models."""
        try:
            self.retail_model = RetailArbitrageModel("v1")
            if retail_model_path:
                self.retail_model.load(retail_model_path)
                logger.info(f"Loaded retail model from {retail_model_path}")

            self.mean_rev_model = MeanReversionModel("v1")
            if mean_rev_model_path:
                self.mean_rev_model.load(mean_rev_model_path)
                logger.info(f"Loaded mean reversion model from {mean_rev_model_path}")

            self._models_loaded = True
        except Exception as e:
            logger.error(f"Failed to load models: {e}")
            self._models_loaded = False

    def process(self, task: Dict[str, Any]) -> Dict[str, Any]:
        """Process a task for the Retail Arbitrage Agent."""
        action = task.get("action", task.get("type", ""))
        params = task.get("parameters", task)

        self.log_action(action, f"Processing: {action}")

        handlers = {
            "analyze": self._handle_analyze,
            "scan_universe": self._handle_scan_universe,
            "generate_signals": self._handle_generate_signals,
            "evaluate_signal": self._handle_evaluate_signal,
            "get_active_signals": self._handle_get_active_signals,
            "update_config": self._handle_update_config,
            "get_status": self._handle_get_status,
        }

        handler = handlers.get(action, self._handle_unknown)
        return handler(params)

    def get_capabilities(self) -> List[str]:
        return self.capabilities

    # =========================================================================
    # CORE ANALYSIS METHODS
    # =========================================================================

    def analyze_retail_inefficiency(
        self,
        symbol: str,
        price_data: "pd.DataFrame",
    ) -> Dict[str, Any]:
        """Analyze a symbol for retail inefficiency opportunities.

        Args:
        ----
            symbol: Stock ticker
            price_data: Recent OHLCV data

        Returns:
        -------
            Analysis dict with inefficiency scores and signals
        """
        from src.ml.feature_engineering import add_technical_indicators
        from src.ml.retail_inefficiency_features import (
            add_retail_inefficiency_features,
        )

        # Add features
        df = add_technical_indicators(price_data.copy())
        df = add_retail_inefficiency_features(df)

        latest = df.iloc[-1]

        # Calculate inefficiency score
        inefficiency_score = latest.get("retail_inefficiency_normalized", 0)

        # Detect specific patterns
        patterns_detected = []

        if latest.get("wide_spread_flag", 0) == 1:
            patterns_detected.append(RetailSignalType.WIDE_SPREAD)

        if latest.get("stale_quote_streak", 0) >= 2:
            patterns_detected.append(RetailSignalType.STALE_QUOTE)

        if latest.get("capitulation_signal", 0) == 1:
            patterns_detected.append(RetailSignalType.RETAIL_PANIC)

        if latest.get("momentum_chase_long", 0) == 1 and latest.get("overextended", 0) == 1:
            patterns_detected.append(RetailSignalType.RETAIL_EUPHORIA)

        if latest.get("overextended", 0) == 1:
            patterns_detected.append(RetailSignalType.MOMENTUM_EXHAUSTION)

        if latest.get("liquidity_vacuum", 0) == 1:
            patterns_detected.append(RetailSignalType.LIQUIDITY_VACUUM)

        # Model prediction (if loaded)
        model_prob = 0.5
        model_conf = 0.0

        if self._models_loaded and self.retail_model is not None:
            try:
                feature_cols = self.retail_model.feature_names
                available_cols = [c for c in feature_cols if c in df.columns]
                if len(available_cols) > 0.5 * len(feature_cols):
                    X = df[available_cols].iloc[-1:].fillna(0)
                    proba = self.retail_model.predict_proba(X)
                    model_prob = proba[0, 1]
                    model_conf = abs(model_prob - 0.5) * 2
            except Exception as e:
                logger.warning(f"Model inference failed: {e}")

        return {
            "symbol": symbol,
            "timestamp": datetime.now().isoformat(),
            "inefficiency_score": inefficiency_score,
            "patterns_detected": [p.value for p in patterns_detected],
            "model_probability": model_prob,
            "model_confidence": model_conf,
            "spread_z_score": latest.get("spread_z_score", 0),
            "price_extension": latest.get("price_extension", 0),
            "volume_ratio": latest.get("volume_ratio", 1),
            "current_price": latest.get("close", 0),
            "opportunity_present": len(patterns_detected) > 0 and inefficiency_score > 0.3,
        }

    def generate_signal(
        self,
        symbol: str,
        analysis: Dict[str, Any],
        current_price: float,
    ) -> Optional[RetailArbitrageSignal]:
        """Generate a trade signal from analysis.

        Args:
        ----
            symbol: Stock ticker
            analysis: Output from analyze_retail_inefficiency
            current_price: Current market price

        Returns:
        -------
            RetailArbitrageSignal or None
        """
        if not analysis.get("opportunity_present", False):
            return None

        inefficiency_score = analysis.get("inefficiency_score", 0)
        patterns = analysis.get("patterns_detected", [])
        model_prob = analysis.get("model_probability", 0.5)
        price_extension = analysis.get("price_extension", 0)

        # Determine direction
        if RetailSignalType.RETAIL_PANIC.value in patterns:
            # Fade panic - go long
            direction = "long"
            signal_type = RetailSignalType.RETAIL_PANIC
            reasoning = "Retail capitulation detected - fade the panic"

        elif RetailSignalType.RETAIL_EUPHORIA.value in patterns or \
             RetailSignalType.MOMENTUM_EXHAUSTION.value in patterns:
            # Fade euphoria - go short
            direction = "short"
            signal_type = RetailSignalType.MOMENTUM_EXHAUSTION
            reasoning = "Overextended retail chase - fade the euphoria"

        elif RetailSignalType.WIDE_SPREAD.value in patterns:
            # Market make the spread
            direction = "long" if model_prob > 0.5 else "short"
            signal_type = RetailSignalType.WIDE_SPREAD
            reasoning = "Wide spread arbitrage opportunity"

        else:
            # Use model prediction
            direction = "long" if model_prob > 0.55 else "short" if model_prob < 0.45 else None
            if direction is None:
                return None
            signal_type = RetailSignalType.ODD_LOT_IMBALANCE
            reasoning = f"Model-driven signal (prob={model_prob:.2f})"

        # Calculate confidence
        confidence = (
            0.3 * inefficiency_score +
            0.4 * abs(model_prob - 0.5) * 2 +
            0.3 * min(len(patterns) / 3, 1)
        )

        if confidence < self.MIN_CONFIDENCE:
            return None

        # Calculate edge
        fair_value = current_price * (1 + (model_prob - 0.5) * 0.02)
        edge_pct = abs(fair_value - current_price) / current_price

        if edge_pct < self.MIN_EDGE_PCT:
            return None

        # Entry/Exit prices
        if direction == "long":
            entry_price = current_price * 0.998  # Slight discount
            target_price = current_price * (1 + self.config["default_target_pct"])
            stop_loss = current_price * (1 - self.config["default_stop_pct"])
        else:
            entry_price = current_price * 1.002  # Slight premium
            target_price = current_price * (1 - self.config["default_target_pct"])
            stop_loss = current_price * (1 + self.config["default_stop_pct"])

        # Urgency
        if RetailSignalType.RETAIL_PANIC.value in patterns:
            urgency = TradeUrgency.IMMEDIATE
        elif len(patterns) >= 2:
            urgency = TradeUrgency.FAST
        else:
            urgency = TradeUrgency.STANDARD

        # Position size
        size_pct = min(
            self.config["max_position_size_pct"],
            confidence * 0.1,  # Scale with confidence
        )

        signal = RetailArbitrageSignal(
            signal_id=f"retail_{uuid.uuid4().hex[:8]}",
            signal_type=signal_type,
            symbol=symbol,
            timestamp=datetime.now(),
            direction=direction,
            confidence=confidence,
            suggested_size_pct=size_pct,
            current_price=current_price,
            fair_value=fair_value,
            edge_pct=edge_pct,
            entry_price=entry_price,
            target_price=target_price,
            stop_loss=stop_loss,
            urgency=urgency,
            retail_inefficiency_score=inefficiency_score,
            reasoning=reasoning,
            model_probability=model_prob,
            model_confidence=analysis.get("model_confidence", 0),
        )

        self.signals_generated.append(signal)
        logger.info(f"Generated signal: {signal.symbol} {signal.direction} @ {signal.entry_price:.2f}")

        return signal

    def scan_universe(
        self,
        symbols: List[str],
        price_data_dict: Dict[str, "pd.DataFrame"],
    ) -> List[RetailArbitrageSignal]:
        """Scan a universe of symbols for opportunities.

        Args:
        ----
            symbols: List of symbols to scan
            price_data_dict: Dict of symbol -> price DataFrame

        Returns:
        -------
            List of signals, sorted by confidence
        """
        signals = []

        for symbol in symbols:
            if symbol not in price_data_dict:
                continue

            price_data = price_data_dict[symbol]
            if len(price_data) < 50:
                continue

            try:
                analysis = self.analyze_retail_inefficiency(symbol, price_data)

                if analysis.get("opportunity_present", False):
                    current_price = analysis.get("current_price", 0)
                    signal = self.generate_signal(symbol, analysis, current_price)

                    if signal:
                        signals.append(signal)

            except Exception as e:
                logger.warning(f"Error analyzing {symbol}: {e}")
                continue

        # Sort by confidence
        signals.sort(key=lambda s: -s.confidence)

        logger.info(f"Scan complete: {len(signals)} signals from {len(symbols)} symbols")
        return signals

    # =========================================================================
    # TASK HANDLERS
    # =========================================================================

    def _handle_analyze(self, params: Dict) -> Dict:
        """Handle analyze request."""
        symbol = params.get("symbol", "")
        price_data = params.get("price_data")

        if not symbol or price_data is None:
            return {"status": "error", "message": "Missing symbol or price_data"}

        analysis = self.analyze_retail_inefficiency(symbol, price_data)
        return {"status": "success", "analysis": analysis}

    def _handle_scan_universe(self, params: Dict) -> Dict:
        """Handle universe scan request."""
        symbols = params.get("symbols", [])
        price_data_dict = params.get("price_data", {})

        signals = self.scan_universe(symbols, price_data_dict)

        return {
            "status": "success",
            "signals_found": len(signals),
            "signals": [s.to_dict() for s in signals[:20]],
        }

    def _handle_generate_signals(self, params: Dict) -> Dict:
        """Generate signals for given data."""
        symbol = params.get("symbol", "")
        price_data = params.get("price_data")
        current_price = params.get("current_price", 0)

        analysis = self.analyze_retail_inefficiency(symbol, price_data)
        signal = self.generate_signal(symbol, analysis, current_price or analysis.get("current_price", 0))

        if signal:
            return {"status": "success", "signal": signal.to_dict()}
        return {"status": "success", "signal": None, "message": "No opportunity detected"}

    def _handle_evaluate_signal(self, params: Dict) -> Dict:
        """Evaluate an existing signal."""
        signal_id = params.get("signal_id", "")
        signal = next((s for s in self.signals_generated if s.signal_id == signal_id), None)

        if not signal:
            return {"status": "error", "message": "Signal not found"}

        return {
            "status": "success",
            "signal": signal.to_dict(),
            "age_seconds": (datetime.now() - signal.timestamp).total_seconds(),
            "still_valid": (datetime.now() - signal.timestamp).total_seconds() < 300,  # 5 min expiry
        }

    def _handle_get_active_signals(self, params: Dict) -> Dict:
        """Get all active signals."""
        max_age_seconds = params.get("max_age_seconds", 300)

        active = [
            s for s in self.signals_generated
            if (datetime.now() - s.timestamp).total_seconds() < max_age_seconds
        ]

        return {
            "status": "success",
            "count": len(active),
            "signals": [s.to_dict() for s in active],
        }

    def _handle_update_config(self, params: Dict) -> Dict:
        """Update agent configuration."""
        for key, value in params.items():
            if key in self.config:
                self.config[key] = value

        return {"status": "success", "config": self.config}

    def _handle_get_status(self, params: Dict) -> Dict:
        """Get agent status."""
        return {
            "status": "success",
            "agent": self.name,
            "models_loaded": self._models_loaded,
            "signals_generated": len(self.signals_generated),
            "signals_executed": self.signals_executed,
            "total_edge_captured": self.total_edge_captured,
            "config": self.config,
        }

    def _handle_unknown(self, params: Dict) -> Dict:
        return {"status": "error", "message": "Unknown action"}

    def log_action(self, action: str, description: str):
        logger.info(f"[RetailArbitrage] {action}: {description}")


# Singleton
_retail_arb_agent: Optional[RetailArbitrageAgent] = None


def get_retail_arbitrage_agent() -> RetailArbitrageAgent:
    """Get the Retail Arbitrage Agent singleton."""
    global _retail_arb_agent
    if _retail_arb_agent is None:
        _retail_arb_agent = RetailArbitrageAgent()
    return _retail_arb_agent
